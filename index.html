<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Zombie Movement Toy</title>
<style>
/* ============================================================
   STYLES
   Minimal styling — canvas-centric layout with UI overlay.
   ============================================================ */
* { margin: 0; padding: 0; box-sizing: border-box; }

body {
    background: #1a1a2e;
    display: flex;
    flex-direction: column;
    align-items: center;
    font-family: 'Segoe UI', Arial, sans-serif;
    color: #e0e0e0;
    overflow-x: hidden;
}

#game-container {
    position: relative;
    margin-top: 10px;
}

canvas {
    display: block;
    border: 2px solid #444;
    background: #16213e;
}

/* --- Sanity Slider (top bar) --- */
#sanity-bar {
    width: 100%;
    max-width: 1284px; /* updated dynamically by resizeCanvas() */
    padding: 8px 16px;
    background: #0f3460;
    display: flex;
    align-items: center;
    gap: 12px;
    border-radius: 0 0 6px 6px;
}

#sanity-bar label {
    font-weight: bold;
    font-size: 14px;
    white-space: nowrap;
    min-width: 180px;
}

#sanity-slider {
    flex: 1;
    height: 6px;
    cursor: pointer;
    accent-color: #53d769;
}

/* --- Debug Panel (overlaid on canvas) --- */
#debug-panel {
    position: absolute;
    top: 8px;
    right: 8px;
    background: rgba(0, 0, 0, 0.75);
    padding: 8px 12px;
    font-family: 'Consolas', 'Courier New', monospace;
    font-size: 12px;
    line-height: 1.5;
    color: #aaffaa;
    border-radius: 4px;
    pointer-events: none;
    white-space: pre;
    min-width: 200px;
}

/* --- Tuning Panel (collapsible side panel) --- */
#tuning-toggle {
    position: absolute;
    top: 8px;
    left: 8px;
    background: rgba(0, 0, 0, 0.75);
    color: #e0e0e0;
    border: 1px solid #555;
    padding: 4px 10px;
    font-size: 12px;
    cursor: pointer;
    border-radius: 4px;
    z-index: 10;
}
#tuning-toggle:hover { background: rgba(50, 50, 80, 0.9); }

#tuning-panel {
    position: absolute;
    top: 36px;
    left: 8px;
    background: rgba(0, 0, 0, 0.85);
    padding: 10px 14px;
    font-family: 'Consolas', 'Courier New', monospace;
    font-size: 11px;
    line-height: 1.8;
    color: #cccccc;
    border-radius: 4px;
    max-height: 750px;
    overflow-y: auto;
    width: 280px;
    display: none;
    z-index: 5;
}

#tuning-panel.open { display: block; }

#tuning-panel label {
    display: flex;
    justify-content: space-between;
    align-items: center;
    gap: 6px;
}

#tuning-panel input[type="range"] {
    width: 100px;
    height: 4px;
    cursor: pointer;
    accent-color: #53d769;
}

#tuning-panel .section-label {
    color: #ffcc00;
    font-weight: bold;
    margin-top: 6px;
    border-bottom: 1px solid #555;
    padding-bottom: 2px;
}

/* --- Gone overlay --- */
#gone-overlay {
    position: absolute;
    top: 0; left: 0; right: 0; bottom: 0;
    display: none;
    justify-content: center;
    align-items: center;
    background: rgba(0, 0, 0, 0.6);
    pointer-events: none;
    z-index: 20;
}
#gone-overlay.active { display: flex; }
#gone-overlay span {
    font-size: 64px;
    font-weight: bold;
    color: #ff3333;
    text-shadow: 0 0 30px #ff0000, 0 0 60px #880000;
    font-family: 'Consolas', monospace;
    letter-spacing: 8px;
}

/* --- Level Generator controls in tuning panel --- */
.gen-seed-input {
    width: 70px;
    background: #0a0a1a;
    border: 1px solid #555;
    color: #e0e0e0;
    padding: 3px 6px;
    font-family: 'Consolas', monospace;
    font-size: 11px;
    border-radius: 3px;
    text-align: right;
}
.gen-button-row {
    display: flex;
    gap: 4px;
    margin: 6px 0;
}
.gen-button-row button {
    flex: 1;
    background: #1a1a3e;
    color: #e0e0e0;
    border: 1px solid #555;
    padding: 4px 8px;
    font-family: 'Consolas', monospace;
    font-size: 11px;
    cursor: pointer;
    border-radius: 3px;
}
.gen-button-row button:hover { background: #2a2a5e; border-color: #53d769; }

/* --- Controls hint --- */
#controls-hint {
    margin-top: 8px;
    font-size: 12px;
    color: #888;
    text-align: center;
}
</style>
</head>
<body>

<div id="sanity-bar">
    <label id="sanity-label">Sanity: 12.0 (Lucid)</label>
    <input type="range" id="sanity-slider" min="0" max="12" step="0.1" value="12">
</div>

<div id="game-container">
    <canvas id="game-canvas"></canvas>
    <div id="debug-panel"></div>
    <button id="tuning-toggle">Tuning</button>
    <div id="tuning-panel"></div>
    <div id="gone-overlay"><span>MIND LOST</span></div>
</div>

<div id="controls-hint">
    WASD or Arrow Keys to move &bull; Space to jump &bull; Slider to change sanity tier
</div>

<script>
// ============================================================
// TUNABLE CONSTANTS
// All movement parameters live here. The tuning panel reads and
// writes these at runtime. Values sourced from paper prototype
// MC simulations (zombie-platformer repo docs/GDD.md).
// ============================================================

// --- Base movement (Lucid tier) ---
let BASE_MAX_SPEED = 300;          // px/s — top horizontal speed
let BASE_ACCELERATION = 1800;      // px/s² — how fast we reach max speed
let BASE_DECELERATION = 3200;      // px/s² — friction when no input
let BASE_AIR_CONTROL = 0.8;        // multiplier on accel while airborne

// --- Jump ---
let JUMP_VELOCITY = -600;          // px/s — initial upward velocity (negative = up)
let GRAVITY = 1400;                // px/s² — downward pull
let COYOTE_TIME = 0.1;            // seconds — grace period after leaving ground
let JUMP_BUFFER_TIME = 0.1;       // seconds — pre-landing jump input memory

// --- Sanity tier multipliers ---
// Slipping (sanity 4-6.99): faster but slightly less controlled
let SLIPPING_SPEED_MULT = 1.25;
let SLIPPING_ACCEL_MULT = 1.3;
let SLIPPING_AIR_CONTROL_MULT = 0.85;

// Feral (sanity 0.01-3.99): fast, strong accel, poor air control
let FERAL_SPEED_MULT = 1.5;
let FERAL_ACCEL_MULT = 1.6;
let FERAL_AIR_CONTROL_MULT = 0.5;

// --- Sanity sliding scales ---
// These scale smoothly with sanity (not stepped by tier).
// At sanity 12 the zombie gets base values; at sanity 0 it gets
// the FERAL_*_MULT × base. Linear interpolation between.
let FERAL_JUMP_MULT = 1.6;        // jump strengthens as sanity drops
let FERAL_DECEL_MULT = 0.5;       // friction weakens as sanity drops (more slidey)

// --- Input drift ---
// Drift is the Thrill of Danger mechanic (Garneau/Heeter). Tuned
// for bigger, rarer impulses so each drift event is a noticeable
// "oh shit" moment rather than constant low-grade annoyance.
// Airborne multiplier makes drift scariest when it matters most
// (mid-jump over a gap) and ignorable on flat ground.

// Slipping drift: noticeable but manageable
let SLIPPING_DRIFT_MIN_INTERVAL = 1.0;   // seconds (was 0.5)
let SLIPPING_DRIFT_MAX_INTERVAL = 2.5;   // (was 1.5)
let SLIPPING_DRIFT_IMPULSE = 100;        // px/s (was 50)

// Feral drift: large, scary impulses + input delay on direction changes
let FERAL_DRIFT_MIN_INTERVAL = 0.8;      // seconds (was 0.3)
let FERAL_DRIFT_MAX_INTERVAL = 1.8;      // (was 0.8)
let FERAL_DRIFT_IMPULSE = 500;           // px/s (tuned from playtest)
let FERAL_INPUT_DELAY = 0.05;            // seconds — delay on direction reversal

// Airborne drift amplification — drift is scarier mid-jump
let DRIFT_AIRBORNE_MULT = 2.0;           // impulse multiplier while not grounded

// ============================================================
// TILE MAP
// "Sanity Gauntlet" — 40 x 25 tiles. Designed so platforms are
// IMPOSSIBLE at full Lucid (sanity 12) and require progressively
// lower sanity to reach. Forces the player to trade control for
// ability, testing the core design tension.
//
// Jump peaks by sanity (FERAL_JUMP_MULT = 1.6):
//   Sanity 12 (Lucid):    peak ~129px (4 tiles)
//   Sanity  9 (Lucid):    peak ~170px (5.3 tiles)
//   Sanity  5 (Slipping): peak ~234px (7.3 tiles)
//   Sanity  3 (Feral):    peak ~270px (8.4 tiles)
//   Sanity  1 (Feral):    peak ~309px (9.7 tiles)
//
// Tier layout (gap from tier below):
//   Ground  = row 24 (runway, any sanity)
//   Lucid   = row 21 (3 rows up — easy at sanity 12)
//   Slip    = row 16 (5 rows up — needs sanity ≤ 9)
//   Feral   = row  8 (8 rows up — needs sanity ≤ 3)
//   Summit  = row  2 (6 rows up — already Feral, easy)
//
// Row 21 also has a 10-tile horizontal gap: Lucid max range
// is ~8 tiles, so the gap requires Feral speed to cross.
// ============================================================

const TILE_SIZE = 32;
let MAP_COLS = 40;
let MAP_ROWS = 25;

const PRESET_GAUNTLET = [
    '........................................', // row 0
    '........................................', // row 1
    '......====......====....................', // row 2  Summit
    '........................................', // row 3
    '........................................', // row 4
    '........................................', // row 5
    '........................................', // row 6
    '........................................', // row 7
    '..====..............====..........====..', // row 8  Feral zone
    '........................................', // row 9
    '........................................', // row 10
    '........................................', // row 11
    '........................................', // row 12
    '........................................', // row 13
    '........................................', // row 14
    '........................................', // row 15
    '====..........====..........====........', // row 16 Slipping zone
    '........................................', // row 17
    '........................................', // row 18
    '........................................', // row 19
    '........................................', // row 20
    '....====..====..====..........====..====', // row 21 Lucid zone (10-tile gap)
    '........................................', // row 22
    '........................................', // row 23
    '========================================', // row 24 Ground (runway)
];

let MAP_DATA = [...PRESET_GAUNTLET];

// Parse map into a 2D boolean grid: true = solid tile
let tileMap = MAP_DATA.map(row =>
    Array.from(row).map(ch => ch === '=')
);

// ============================================================
// LEVEL GENERATOR
// Procedural physics-aware platform generation. Calculates the
// jump envelope from the actual physics constants, builds
// layers bottom-up, adds stepping stones, then validates
// reachability via BFS.
// ============================================================

/** Seeded PRNG (splitmix32) — returns a function producing 0..1 floats */
function splitmix32(seed) {
    let s = seed | 0;
    return function() {
        s |= 0;
        s = s + 0x9e3779b9 | 0;
        let t = s ^ (s >>> 16);
        t = Math.imul(t, 0x21f0aaad);
        t = t ^ (t >>> 15);
        t = Math.imul(t, 0x735a2d97);
        t = t ^ (t >>> 15);
        return (t >>> 0) / 4294967296;
    };
}

/** Calculate jump envelope from real physics constants at a given sanity */
function calcJumpEnvelope(san) {
    // Smooth interpolation: t=0 at sanity 12, t=1 at sanity 0
    const t = Math.max(0, Math.min(1, (12 - san) / 12));
    const jumpVel = Math.abs(JUMP_VELOCITY * (1 + t * (FERAL_JUMP_MULT - 1)));

    // Peak height from kinematics: h = v² / (2g)
    const peakPx = (jumpVel * jumpVel) / (2 * GRAVITY);
    const maxUpTiles = Math.floor(peakPx / TILE_SIZE);

    // Horizontal range at peak: time_to_peak = v/g, distance = speed * time
    let maxSpeed = BASE_MAX_SPEED;
    if (san < 4) maxSpeed *= FERAL_SPEED_MULT;
    else if (san < 7) maxSpeed *= SLIPPING_SPEED_MULT;
    const timeToPeak = jumpVel / GRAVITY;
    const horizPx = maxSpeed * timeToPeak;
    const maxAcrossTiles = Math.floor(horizPx / TILE_SIZE);

    return { maxUpTiles, maxAcrossTiles };
}

/** Quick pairwise reachability check (elliptical envelope) */
function canReachPlatform(ax, ay, bx, by, maxUp, maxAcross) {
    const dx = Math.abs(bx - ax);
    const dy = ay - by; // positive = jumping up
    if (dy <= 0) return dx <= maxAcross + 1;
    return (dx / (maxAcross + 1)) ** 2 + (dy / (maxUp + 0.5)) ** 2 <= 1;
}

/** BFS reachability validation — removes platforms unreachable from ground */
function validateReachability(grid, w, h, maxUp, maxAcross) {
    const groundY = h - 1;

    function solid(x, y) {
        if (x < 0 || x >= w || y < 0 || y >= h) return true;
        return grid[y][x];
    }
    function canStand(x, y) {
        if (solid(x, y)) return false;
        return y === h - 1 || solid(x, y + 1);
    }
    function gravity(x, y) {
        while (y < h - 1 && !solid(x, y + 1)) y++;
        if (solid(x, y)) return null;
        return { x, y };
    }

    const reachable = new Set();
    const visited = new Set();
    const queue = [];

    // Seed from ground-level standing positions
    for (let x = 0; x < w; x++) {
        for (let y = groundY - 2; y <= groundY; y++) {
            if (y >= 0 && canStand(x, y)) {
                const key = `${x},${y}`;
                if (!visited.has(key)) {
                    visited.add(key);
                    queue.push({ x, y });
                }
            }
        }
    }

    while (queue.length > 0) {
        const cur = queue.shift();
        reachable.add(`${cur.x},${cur.y}`);
        const moves = [];

        // Horizontal moves
        for (const dx of [-1, 1]) {
            const nx = cur.x + dx;
            if (!solid(nx, cur.y)) {
                const landed = gravity(nx, cur.y);
                if (landed) moves.push(landed);
            }
        }

        // Jumps
        if (canStand(cur.x, cur.y)) {
            for (let jumpH = 1; jumpH <= maxUp; jumpH++) {
                const upY = cur.y - jumpH;
                let clear = true;
                for (let cy = 1; cy <= jumpH; cy++) {
                    if (solid(cur.x, cur.y - cy)) { clear = false; break; }
                }
                if (!clear) break;

                const landed = gravity(cur.x, upY);
                if (landed && (landed.x !== cur.x || landed.y !== cur.y)) moves.push(landed);

                for (const ddx of [-1, 1]) {
                    for (let reach = 1; reach <= maxAcross; reach++) {
                        const ax = cur.x + ddx * reach;
                        let hClear = true;
                        for (let r = 1; r <= reach; r++) {
                            if (solid(cur.x + ddx * r, upY)) { hClear = false; break; }
                        }
                        if (!hClear) break;
                        const landed2 = gravity(ax, upY);
                        if (landed2) moves.push(landed2);
                    }
                }
            }
        }

        for (const m of moves) {
            const key = `${m.x},${m.y}`;
            if (!visited.has(key)) {
                visited.add(key);
                queue.push(m);
            }
        }
    }

    // Remove platform tiles where the standing surface is unreachable
    for (let y = 1; y < h - 1; y++) {
        for (let x = 1; x < w - 1; x++) {
            if (!grid[y][x]) continue;
            if (y === 0) continue;
            if (!canStand(x, y - 1)) continue;
            if (!reachable.has(`${x},${y - 1}`)) {
                grid[y][x] = false;
            }
        }
    }
}

/** Place a row of solid tiles, clamped to playable area */
function placeRow(grid, y, x1, x2, width) {
    for (let x = Math.max(1, x1); x <= Math.min(width - 2, x2); x++) {
        grid[y][x] = true;
    }
}

/** Random platform length with personality: mix of tiny, medium, and wide */
function randPlatLen(rng, density) {
    const roll = rng();
    if (roll < 0.25) return 1 + Math.floor(rng() * 2);                         // tiny: 1-2
    if (roll < 0.55) return 3 + Math.floor(rng() * 2);                         // medium: 3-4
    return 5 + Math.floor(rng() * Math.max(1, Math.round(3 * density)));       // wide: 5-7+
}

/** Generate a single section by archetype */
function generateSection(grid, type, sx, ex, groundY, height, width, rng, density, maxUp, maxAcross) {
    const secW = ex - sx + 1;
    const clamp = (x) => Math.max(1, Math.min(x, width - 2));

    switch (type) {

        case 'canyon': {
            // Ground on sides, jumpable gap in the middle
            const gapW = 2 + Math.floor(rng() * Math.min(maxAcross - 1, secW - 6));
            const gapMid = sx + Math.floor(secW / 2) + Math.floor(rng() * 3) - 1;
            const gs = clamp(gapMid - Math.floor(gapW / 2));
            const ge = clamp(gs + gapW - 1);

            for (let x = sx; x <= ex; x++) {
                if (x < gs || x > ge) grid[groundY][x] = true;
            }

            // Bridge platform above the gap
            const bridgeY = groundY - Math.max(2, Math.floor(maxUp * 0.4));
            if (bridgeY > 2) {
                placeRow(grid, bridgeY, gs - 1, ge + 1, width);
            }

            // Upper reward platform
            const upperY = bridgeY - Math.max(2, Math.floor(maxUp * 0.5));
            if (upperY > 2 && secW >= 8) {
                const midX = sx + Math.floor(secW / 2);
                const pLen = randPlatLen(rng, density);
                placeRow(grid, upperY, midX - Math.floor(pLen / 2), midX + Math.ceil(pLen / 2), width);
            }
            break;
        }

        case 'tower': {
            // Ground floor
            for (let x = sx; x <= ex; x++) grid[groundY][x] = true;

            // Vertical stack of alternating offset platforms
            const towerCenter = sx + Math.floor(secW / 2) + Math.floor(rng() * 3) - 1;
            let towerY = groundY;
            let tier = 0;
            while (true) {
                const stepUp = 2 + Math.floor(rng() * Math.max(1, maxUp - 2));
                const nextY = towerY - stepUp;
                if (nextY <= 2) break;

                const offset = (tier % 2 === 0)
                    ? -(1 + Math.floor(rng() * 2))
                    : (1 + Math.floor(rng() * 2));
                const pLen = randPlatLen(rng, density);
                const px = clamp(towerCenter + offset - Math.floor(pLen / 2));
                placeRow(grid, nextY, px, px + pLen - 1, width);

                towerY = nextY;
                tier++;
            }

            // Side approach platform
            const sideX = (towerCenter - sx > secW / 2) ? sx + 1 : ex - 4;
            const sLen = 3 + Math.floor(rng() * 3);
            const sideY = groundY - (2 + Math.floor(rng() * Math.max(1, maxUp - 2)));
            if (sideY > 2) {
                placeRow(grid, sideY, clamp(sideX), clamp(sideX + sLen - 1), width);
            }
            break;
        }

        case 'open': {
            // Partial ground with gaps and raised sections
            let x = sx;
            while (x <= ex) {
                if (rng() < 0.65) {
                    const segLen = 3 + Math.floor(rng() * 5);
                    for (let gx = x; gx < Math.min(x + segLen, ex + 1); gx++) {
                        grid[groundY][gx] = true;
                    }
                    // Occasional raised bump
                    if (rng() < 0.3 && segLen > 3) {
                        const bLen = 2 + Math.floor(rng() * 2);
                        for (let bx = x + 1; bx < Math.min(x + 1 + bLen, ex + 1); bx++) {
                            grid[groundY - 1][bx] = true;
                        }
                    }
                    x += segLen;
                } else {
                    x += 1 + Math.floor(rng() * Math.min(3, maxAcross));
                }
            }

            // Scattered platforms at various heights — mix of sizes
            const platCount = 2 + Math.floor(rng() * 4);
            for (let p = 0; p < platCount; p++) {
                const px = sx + 1 + Math.floor(rng() * (secW - 2));
                const py = 3 + Math.floor(rng() * (groundY - 5));
                const pLen = randPlatLen(rng, density);
                placeRow(grid, py, clamp(px), clamp(px + pLen - 1), width);
            }
            break;
        }

        case 'corridor': {
            // Full ground with low ceiling — creates cramped lower path
            for (let x = sx; x <= ex; x++) grid[groundY][x] = true;

            const ceilY = groundY - 3 - Math.floor(rng() * 2);
            for (let x = sx; x <= ex; x++) grid[ceilY][x] = true;

            // Punch gaps in the ceiling for transitions
            const gapCount = 1 + Math.floor(rng() * 2);
            for (let g = 0; g < gapCount; g++) {
                const gx = sx + 1 + Math.floor(rng() * (secW - 4));
                const gLen = 2 + Math.floor(rng() * 2);
                for (let x = gx; x < Math.min(gx + gLen, ex + 1); x++) {
                    grid[ceilY][x] = false;
                }
            }

            // Upper platforms above the ceiling (risk/reward high path)
            const upperCount = 1 + Math.floor(rng() * 2);
            for (let u = 0; u < upperCount; u++) {
                const ux = sx + 1 + Math.floor(rng() * (secW - 4));
                const uy = ceilY - (2 + Math.floor(rng() * Math.max(1, maxUp - 2)));
                if (uy > 2) {
                    const uLen = randPlatLen(rng, density);
                    placeRow(grid, uy, clamp(ux), clamp(ux + uLen - 1), width);
                }
            }

            // Raised ground bump
            if (rng() < 0.5) {
                const bx = sx + 1 + Math.floor(rng() * (secW - 4));
                const bLen = 2 + Math.floor(rng() * 3);
                for (let x = bx; x < Math.min(bx + bLen, ex + 1); x++) {
                    grid[groundY - 1][x] = true;
                }
            }
            break;
        }

        case 'staircase': {
            // Ascending or descending chain of platforms
            const ascending = rng() < 0.5;

            // Ground on the starting side
            const gStart = ascending ? sx : sx + Math.floor(secW * 0.5);
            const gEnd = ascending ? sx + Math.floor(secW * 0.5) : ex;
            for (let x = gStart; x <= gEnd; x++) grid[groundY][x] = true;

            // Step chain
            const stepCount = 3 + Math.floor(rng() * 3);
            let stepY = groundY;
            let stepX = ascending ? sx + 2 : ex - 2;
            const dir = ascending ? 1 : -1;

            for (let s = 0; s < stepCount; s++) {
                const rise = 1 + Math.floor(rng() * Math.max(1, Math.floor(maxUp * 0.4)));
                const run = 2 + Math.floor(rng() * Math.max(1, maxAcross - 1));
                stepY -= rise;
                stepX += dir * run;
                if (stepY <= 2 || stepX < sx + 1 || stepX > ex - 1) break;

                const pLen = randPlatLen(rng, density);
                placeRow(grid, stepY, clamp(stepX), clamp(stepX + pLen - 1), width);
            }
            break;
        }
    }
}

/** Inject 1-2 landmark features for visual identity */
function injectLandmarks(grid, width, height, groundY, rng, maxUp) {
    const count = 1 + Math.floor(rng() * 2);
    const types = ['pillar', 'floater', 'overhang'];

    for (let i = 0; i < count; i++) {
        const type = types[Math.floor(rng() * types.length)];

        switch (type) {
            case 'pillar': {
                // Tall 1-wide column rising from ground
                const px = 3 + Math.floor(rng() * (width - 6));
                const pillarH = 3 + Math.floor(rng() * 5);
                for (let dy = 1; dy <= pillarH && groundY - dy > 1; dy++) {
                    grid[groundY - dy][px] = true;
                }
                break;
            }
            case 'floater': {
                // Single floating tile in open space
                const fx = 3 + Math.floor(rng() * (width - 6));
                const fy = 3 + Math.floor(rng() * (height - 8));
                grid[fy][fx] = true;
                break;
            }
            case 'overhang': {
                // Hang 1-2 tiles below an existing platform edge
                for (let attempt = 0; attempt < 15; attempt++) {
                    const ox = 2 + Math.floor(rng() * (width - 4));
                    const oy = 3 + Math.floor(rng() * (height - 6));
                    if (grid[oy][ox] && oy + 1 < groundY && !grid[oy + 1][ox]) {
                        grid[oy + 1][ox] = true;
                        if (rng() < 0.5 && ox + 1 < width - 1 &&
                            grid[oy][ox + 1] && !grid[oy + 1][ox + 1]) {
                            grid[oy + 1][ox + 1] = true;
                        }
                        break;
                    }
                }
                break;
            }
        }
    }
}

/** Generate a level with the given parameters */
function generateLevel(width, height, density, minSanity, seed) {
    const rng = splitmix32(seed);
    const { maxUpTiles, maxAcrossTiles } = calcJumpEnvelope(minSanity);
    const groundY = height - 1;

    // Initialize empty grid with walls and ceiling
    const grid = [];
    for (let y = 0; y < height; y++) {
        grid[y] = [];
        for (let x = 0; x < width; x++) grid[y][x] = false;
    }
    for (let y = 0; y < height; y++) { grid[y][0] = true; grid[y][width - 1] = true; }
    for (let x = 0; x < width; x++) grid[0][x] = true;

    // --- SECTION-BASED GENERATION ---
    const archetypes = ['canyon', 'tower', 'open', 'corridor', 'staircase'];
    const sectionCount = Math.max(3, Math.min(5, Math.floor(width / 10)));
    const secW = Math.floor((width - 2) / sectionCount);

    const sections = [];
    let lastType = null;
    for (let i = 0; i < sectionCount; i++) {
        const sx = 1 + i * secW;
        const ex = (i === sectionCount - 1) ? width - 2 : sx + secW - 1;
        let available = archetypes.filter(t => t !== lastType);
        const type = available[Math.floor(rng() * available.length)];
        lastType = type;
        sections.push({ sx, ex, type });
    }

    // Guarantee at least one tower or canyon for vertical interest
    if (!sections.some(s => s.type === 'tower' || s.type === 'canyon')) {
        const idx = 1 + Math.floor(rng() * Math.max(1, sections.length - 2));
        sections[idx].type = rng() < 0.5 ? 'tower' : 'canyon';
    }

    // Generate each section
    for (const sec of sections) {
        generateSection(grid, sec.type, sec.sx, sec.ex,
            groundY, height, width, rng, density, maxUpTiles, maxAcrossTiles);
    }

    // Ensure ground continuity at section boundaries (2 tiles each edge)
    for (const sec of sections) {
        grid[groundY][sec.sx] = true;
        if (sec.sx + 1 <= sec.ex) grid[groundY][sec.sx + 1] = true;
        grid[groundY][sec.ex] = true;
        if (sec.ex - 1 >= sec.sx) grid[groundY][sec.ex - 1] = true;
    }

    // --- LANDMARKS ---
    injectLandmarks(grid, width, height, groundY, rng, maxUpTiles);

    // --- BFS REACHABILITY VALIDATION ---
    validateReachability(grid, width, height, maxUpTiles, maxAcrossTiles);

    return grid;
}

/** Resize canvas to match current map dimensions */
function resizeCanvas() {
    canvas.width = MAP_COLS * TILE_SIZE;
    canvas.height = MAP_ROWS * TILE_SIZE;
    document.getElementById('sanity-bar').style.maxWidth = (MAP_COLS * TILE_SIZE + 4) + 'px';
}

/** Find a valid spawn point and place the zombie there */
function findAndSetSpawn() {
    for (let col = 0; col < MAP_COLS; col++) {
        for (let row = MAP_ROWS - 1; row >= 0; row--) {
            if (!tileMap[row][col]) continue;
            const h1 = row - 1, h2 = row - 2;
            if (h1 >= 0 && !tileMap[h1][col] && h2 >= 0 && !tileMap[h2][col]) {
                zombie.x = col * TILE_SIZE;
                zombie.y = row * TILE_SIZE - zombie.height;
                zombie.vx = 0;
                zombie.vy = 0;
                zombie.grounded = false;
                return;
            }
        }
    }
}

/** Apply a generated grid as the active level */
function applyLevel(grid, width, height) {
    MAP_COLS = width;
    MAP_ROWS = height;
    tileMap = grid;
    // Build MAP_DATA strings for consistency
    MAP_DATA = grid.map(row => row.map(v => v ? '=' : '.').join(''));
    resizeCanvas();
    findAndSetSpawn();
}

/** Restore the hardcoded Sanity Gauntlet map */
function loadPresetGauntlet() {
    MAP_COLS = 40;
    MAP_ROWS = 25;
    MAP_DATA = [...PRESET_GAUNTLET];
    tileMap = MAP_DATA.map(row => Array.from(row).map(ch => ch === '='));
    resizeCanvas();
    findAndSetSpawn();
    // Update generator sliders to match
    const ws = document.getElementById('gen-width');
    const hs = document.getElementById('gen-height');
    if (ws) { ws.value = 40; document.getElementById('gen-width-val').textContent = '40'; }
    if (hs) { hs.value = 25; document.getElementById('gen-height-val').textContent = '25'; }
}

/** UI: Generate level with current slider values */
function doGenerate() {
    const width = parseInt(document.getElementById('gen-width').value);
    const height = parseInt(document.getElementById('gen-height').value);
    const density = parseInt(document.getElementById('gen-density').value) / 100;
    const minSanity = parseInt(document.getElementById('gen-sanity').value);
    const seed = parseInt(document.getElementById('gen-seed').value) || 42;
    const grid = generateLevel(width, height, density, minSanity, seed);
    applyLevel(grid, width, height);
}

/** UI: Random seed then generate */
function doRandomGenerate() {
    const seed = Math.floor(Math.random() * 999999);
    document.getElementById('gen-seed').value = seed;
    doGenerate();
}

// ============================================================
// GAME STATE
// Mutable runtime state. Kept separate from constants so the
// tuning panel only touches the constants section above.
// ============================================================

const zombie = {
    x: 32,              // spawn position — bottom left, one tile in
    y: (MAP_ROWS - 2) * TILE_SIZE,  // one tile above ground
    width: 32,
    height: 48,
    vx: 0,
    vy: 0,
    grounded: false,
    coyoteTimer: 0,      // time since last grounded (for coyote time)
    jumpBufferTimer: 0,  // time since jump was pressed (for jump buffering)
    wasGrounded: false,   // grounded state from previous frame
};

let sanity = 12;

// Input state
const input = {
    left: false,
    right: false,
    jump: false,
    jumpPressed: false,   // true only on the frame jump is first pressed
    jumpHeld: false,      // true while jump key is held
};

// Drift state
const drift = {
    timer: 0,
    nextInterval: 1.0,    // seconds until next drift impulse
    inputDelayTimer: 0,   // Feral-only: remaining input delay
    inputDelayDirection: 0, // which direction was blocked (-1 left, 1 right, 0 none)
    flashTimer: 0,        // visual feedback: counts down after drift fires
};

// ============================================================
// SANITY TIER HELPERS
// Tier boundaries from paper prototype: Lucid >= 7, Slipping
// 4-6.99, Feral 0.01-3.99, Gone = 0. These thresholds match
// the validated MC simulation parameters.
// ============================================================

function getSanityTier(s) {
    if (s <= 0) return 'Gone';
    if (s < 4) return 'Feral';
    if (s < 7) return 'Slipping';
    return 'Lucid';
}

function getTierColor(tier) {
    switch (tier) {
        case 'Lucid':    return '#53d769'; // green
        case 'Slipping': return '#ffcc00'; // yellow
        case 'Feral':    return '#ff6b35'; // orange
        case 'Gone':     return '#ff3333'; // red
    }
}

function getMaxSpeed() {
    const tier = getSanityTier(sanity);
    if (tier === 'Feral')    return BASE_MAX_SPEED * FERAL_SPEED_MULT;
    if (tier === 'Slipping') return BASE_MAX_SPEED * SLIPPING_SPEED_MULT;
    return BASE_MAX_SPEED;
}

function getAcceleration() {
    const tier = getSanityTier(sanity);
    let accel = BASE_ACCELERATION;
    if (tier === 'Feral')    accel *= FERAL_ACCEL_MULT;
    if (tier === 'Slipping') accel *= SLIPPING_ACCEL_MULT;

    // Reduce acceleration while airborne (air control)
    if (!zombie.grounded) {
        accel *= getAirControl();
    }
    return accel;
}

// Sanity sliding scales share a common interpolation factor:
// t = 0 at sanity 12 (Lucid), t = 1 at sanity 0 (Gone).
function getSanityT() {
    return Math.max(0, Math.min(1, (12 - sanity) / 12));
}

// Deceleration weakens as sanity drops — the zombie can't stop
// its own momentum. Creates the "committed to a direction" feel
// at low sanity (Swink: simulation weight).
function getDeceleration() {
    const t = getSanityT();
    return BASE_DECELERATION * (1 + t * (FERAL_DECEL_MULT - 1));
}

// Jump strengthens as sanity drops — the feral zombie is more
// explosive. Smooth scale, not stepped by tier.
function getJumpVelocity() {
    const t = getSanityT();
    return JUMP_VELOCITY * (1 + t * (FERAL_JUMP_MULT - 1));
}

function getAirControl() {
    const tier = getSanityTier(sanity);
    if (tier === 'Feral')    return BASE_AIR_CONTROL * FERAL_AIR_CONTROL_MULT;
    if (tier === 'Slipping') return BASE_AIR_CONTROL * SLIPPING_AIR_CONTROL_MULT;
    return BASE_AIR_CONTROL;
}

// ============================================================
// INPUT HANDLING
// Tracks key state for movement and jump. Supports both WASD
// and arrow keys. Jump uses both space and W/Up for convenience.
// Architecture note: we track jumpPressed (edge) separately
// from jumpHeld (level) because variable jump height needs to
// know when the key is released, while jump buffering needs to
// know when it was first pressed.
// ============================================================

const keysDown = new Set();

window.addEventListener('keydown', (e) => {
    if (['ArrowLeft', 'ArrowRight', 'ArrowUp', 'ArrowDown',
         'a', 'd', 'w', 's', ' '].includes(e.key)) {
        e.preventDefault();
    }
    if (!keysDown.has(e.key)) {
        keysDown.add(e.key);
        // Edge-triggered jump detection
        if (e.key === ' ' || e.key === 'w' || e.key === 'W' || e.key === 'ArrowUp') {
            input.jumpPressed = true;
        }
    }
});

window.addEventListener('keyup', (e) => {
    keysDown.delete(e.key);
});

// Prevent stuck keys when window loses focus
window.addEventListener('blur', () => {
    keysDown.clear();
});

function processInput() {
    input.left = keysDown.has('ArrowLeft') || keysDown.has('a') || keysDown.has('A');
    input.right = keysDown.has('ArrowRight') || keysDown.has('d') || keysDown.has('D');
    input.jumpHeld = keysDown.has(' ') || keysDown.has('w') || keysDown.has('W') || keysDown.has('ArrowUp');
    // jumpPressed is consumed after use — set in keydown handler, cleared in updateJump
}

// ============================================================
// PHYSICS UPDATE
// Core movement loop. Frame-rate independent via dt. The update
// order matters: gravity -> input accel -> friction -> clamp ->
// position -> collision -> jump timers. This order prevents
// a frame of clipping after position update by resolving
// collisions before the next render.
// ============================================================

function updatePhysics(dt) {
    const tier = getSanityTier(sanity);

    // --- Gone tier: no movement ---
    if (tier === 'Gone') {
        zombie.vx = 0;
        zombie.vy = 0;
        return;
    }

    // --- Gravity ---
    zombie.vy += GRAVITY * dt;

    // --- Horizontal input ---
    // Feral input delay: when reversing direction, block input briefly.
    // This makes momentum feel more committal at low sanity — the zombie's
    // body resists changing direction (Swink: simulation weight).
    let effectiveLeft = input.left;
    let effectiveRight = input.right;

    if (tier === 'Feral' && drift.inputDelayTimer > 0) {
        drift.inputDelayTimer -= dt;
        if (drift.inputDelayDirection === -1) effectiveLeft = false;
        if (drift.inputDelayDirection === 1) effectiveRight = false;
    }

    // Check for direction reversal to trigger Feral input delay
    if (tier === 'Feral') {
        if (effectiveLeft && zombie.vx > 50) {
            drift.inputDelayTimer = FERAL_INPUT_DELAY;
            drift.inputDelayDirection = -1;
            effectiveLeft = false;
        } else if (effectiveRight && zombie.vx < -50) {
            drift.inputDelayTimer = FERAL_INPUT_DELAY;
            drift.inputDelayDirection = 1;
            effectiveRight = false;
        }
    }

    const accel = getAcceleration();
    if (effectiveLeft)  zombie.vx -= accel * dt;
    if (effectiveRight) zombie.vx += accel * dt;

    // --- Friction (deceleration when no horizontal input) ---
    if (!effectiveLeft && !effectiveRight) {
        const friction = getDeceleration() * dt;
        if (zombie.vx > 0)      zombie.vx = Math.max(0, zombie.vx - friction);
        else if (zombie.vx < 0) zombie.vx = Math.min(0, zombie.vx + friction);
    }

    // --- Clamp to max speed ---
    const maxSpeed = getMaxSpeed();
    zombie.vx = Math.max(-maxSpeed, Math.min(maxSpeed, zombie.vx));

    // --- Update position and resolve collisions per-axis ---
    // Moving and resolving one axis at a time prevents the bug where
    // pressing into a wall causes the zombie's x to overlap the wall
    // column, and the ceiling check sees the wall tile and kills the
    // jump. By resolving X first, the zombie's horizontal position is
    // corrected before any vertical checks run.
    zombie.x += zombie.vx * dt;
    clampWorldBoundsX();
    resolveHorizontal();

    zombie.y += zombie.vy * dt;
    clampWorldBoundsY();
    resolveVertical();

    // --- Jump timers ---
    updateJumpTimers(dt);

    // --- Jump execution ---
    updateJump();
}

// ============================================================
// COLLISION DETECTION
// Simple AABB vs tile grid. Each axis is moved and resolved
// independently in updatePhysics: X first, then Y. This
// prevents the "wall eats jump" bug where unresolved horizontal
// overlap causes the ceiling check to see wall tiles.
//
// Ground detection uses zombie.y + zombie.height (feet pixel)
// instead of zombie.y + zombie.height - 1 (last body pixel).
// This fixes a flickering grounded state when the zombie is
// exactly 1.5 tiles tall and perfectly placed on a tile
// boundary — the last body pixel falls in the row above ground.
// ============================================================

function isSolid(col, row) {
    if (col < 0 || col >= MAP_COLS || row < 0 || row >= MAP_ROWS) return false;
    return tileMap[row][col];
}

function clampWorldBoundsX() {
    if (zombie.x < 0) {
        zombie.x = 0;
        zombie.vx = Math.max(0, zombie.vx);
    }
    if (zombie.x + zombie.width > MAP_COLS * TILE_SIZE) {
        zombie.x = MAP_COLS * TILE_SIZE - zombie.width;
        zombie.vx = Math.min(0, zombie.vx);
    }
}

function clampWorldBoundsY() {
    if (zombie.y < 0) {
        zombie.y = 0;
        zombie.vy = Math.max(0, zombie.vy);
    }
    if (zombie.y + zombie.height > MAP_ROWS * TILE_SIZE) {
        zombie.y = MAP_ROWS * TILE_SIZE - zombie.height;
        zombie.vy = 0;
    }
}

function resolveVertical() {
    const left = Math.floor(zombie.x / TILE_SIZE);
    const right = Math.floor((zombie.x + zombie.width - 1) / TILE_SIZE);

    zombie.grounded = false;

    if (zombie.vy >= 0) {
        // Falling or stationary — sense ground at feet.
        // Using zombie.y + zombie.height (not -1) so that when the
        // zombie is exactly on a tile boundary, we detect the tile
        // below its feet rather than the empty row its bottom pixel
        // occupies. This eliminates grounded flicker for non-tile-
        // aligned heights (e.g. 48px = 1.5 tiles).
        const feetRow = Math.floor((zombie.y + zombie.height) / TILE_SIZE);
        for (let col = left; col <= right; col++) {
            if (isSolid(col, feetRow)) {
                zombie.y = feetRow * TILE_SIZE - zombie.height;
                zombie.vy = 0;
                zombie.grounded = true;
                break;
            }
        }
    }

    if (zombie.vy < 0) {
        // Rising — check above
        const topRow = Math.floor(zombie.y / TILE_SIZE);
        for (let col = left; col <= right; col++) {
            if (isSolid(col, topRow)) {
                zombie.y = (topRow + 1) * TILE_SIZE;
                zombie.vy = 0;
                break;
            }
        }
    }
}

function resolveHorizontal() {
    const top = Math.floor(zombie.y / TILE_SIZE);
    const bottom = Math.floor((zombie.y + zombie.height - 1) / TILE_SIZE);

    if (zombie.vx > 0) {
        const rightCol = Math.floor((zombie.x + zombie.width - 1) / TILE_SIZE);
        for (let row = top; row <= bottom; row++) {
            if (isSolid(rightCol, row)) {
                zombie.x = rightCol * TILE_SIZE - zombie.width;
                zombie.vx = 0;
                break;
            }
        }
    }

    if (zombie.vx < 0) {
        const leftCol = Math.floor(zombie.x / TILE_SIZE);
        for (let row = top; row <= bottom; row++) {
            if (isSolid(leftCol, row)) {
                zombie.x = (leftCol + 1) * TILE_SIZE;
                zombie.vx = 0;
                break;
            }
        }
    }
}

// ============================================================
// JUMP SYSTEM
// Implements coyote time, jump buffering, and variable jump
// height. These three features are essential for responsive
// platformer feel (per Swink's input responsiveness model).
//
// Coyote time: after walking off a ledge, the player has a
//   brief window to still jump. Prevents "I was on the edge!"
// Jump buffer: pressing jump slightly before landing queues
//   the jump to fire on landing. Prevents "I pressed jump!"
// Variable height: releasing jump early cuts upward velocity,
//   giving short hops vs full jumps from one button.
// ============================================================

function updateJumpTimers(dt) {
    zombie.wasGrounded = zombie.grounded;

    if (zombie.grounded) {
        zombie.coyoteTimer = 0;
    } else {
        zombie.coyoteTimer += dt;
    }

    if (input.jumpPressed) {
        zombie.jumpBufferTimer = JUMP_BUFFER_TIME;
        input.jumpPressed = false;
    } else {
        zombie.jumpBufferTimer = Math.max(0, zombie.jumpBufferTimer - dt);
    }
}

function updateJump() {
    const canJump = zombie.grounded || zombie.coyoteTimer < COYOTE_TIME;
    const wantsJump = zombie.jumpBufferTimer > 0;

    if (canJump && wantsJump) {
        zombie.vy = getJumpVelocity();
        zombie.grounded = false;
        zombie.coyoteTimer = COYOTE_TIME; // exhaust coyote time to prevent double jump
        zombie.jumpBufferTimer = 0;
    }

    // Variable jump height: releasing jump early cuts upward velocity
    if (!input.jumpHeld && zombie.vy < 0) {
        zombie.vy *= 0.5;
    }
}

// ============================================================
// INPUT DRIFT
// At lower sanity tiers, random horizontal impulses simulate
// the zombie's body fighting the player's intentions. This is
// the key mechanic for Thrill of Danger (Garneau/Heeter) —
// the player should feel slightly out of control without
// feeling cheated.
//
// Tuned for bigger, rarer impulses (scary events, not constant
// annoyance). Amplified while airborne so drift is terrifying
// mid-jump but ignorable on flat ground. Visual flash on drift
// (Swink: feedback layer) so the player can distinguish "the
// zombie fought me" from "I made a bad input."
// ============================================================

function updateDrift(dt) {
    const tier = getSanityTier(sanity);

    // Tick down drift flash regardless of tier
    if (drift.flashTimer > 0) drift.flashTimer -= dt;

    if (tier !== 'Slipping' && tier !== 'Feral') {
        drift.timer = 0;
        drift.nextInterval = 1.0;
        return;
    }

    drift.timer += dt;

    if (drift.timer >= drift.nextInterval) {
        drift.timer = 0;

        let minInterval, maxInterval, impulse;

        if (tier === 'Feral') {
            minInterval = FERAL_DRIFT_MIN_INTERVAL;
            maxInterval = FERAL_DRIFT_MAX_INTERVAL;
            impulse = FERAL_DRIFT_IMPULSE;
        } else {
            minInterval = SLIPPING_DRIFT_MIN_INTERVAL;
            maxInterval = SLIPPING_DRIFT_MAX_INTERVAL;
            impulse = SLIPPING_DRIFT_IMPULSE;
        }

        // Airborne amplification — drift is scariest mid-jump
        if (!zombie.grounded) {
            impulse *= DRIFT_AIRBORNE_MULT;
        }

        // Random next interval
        drift.nextInterval = minInterval + Math.random() * (maxInterval - minInterval);

        // Apply random horizontal impulse
        const direction = Math.random() < 0.5 ? -1 : 1;
        zombie.vx += direction * impulse;

        // Trigger visual flash (0.15s duration)
        drift.flashTimer = 0.15;
    }
}

// ============================================================
// RENDERING
// Canvas-based rendering. Tiles are drawn as colored rectangles,
// the zombie as a green rectangle with "Z" label. Colors shift
// by sanity tier to give visual feedback on current state.
// Architecture note: we clear and redraw every frame rather
// than using dirty rectangles because at 40x15 tiles the fill
// cost is negligible and it avoids artifact bugs.
// ============================================================

const canvas = document.getElementById('game-canvas');
const ctx = canvas.getContext('2d');

// Scale canvas to map size
resizeCanvas();

function render() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // --- Draw tiles ---
    for (let row = 0; row < MAP_ROWS; row++) {
        for (let col = 0; col < MAP_COLS; col++) {
            if (tileMap[row][col]) {
                ctx.fillStyle = '#3a506b';
                ctx.fillRect(col * TILE_SIZE, row * TILE_SIZE, TILE_SIZE, TILE_SIZE);
                // Subtle border for tile edges
                ctx.strokeStyle = '#2c3e50';
                ctx.lineWidth = 1;
                ctx.strokeRect(col * TILE_SIZE, row * TILE_SIZE, TILE_SIZE, TILE_SIZE);
            }
        }
    }

    // --- Draw zombie ---
    const tier = getSanityTier(sanity);
    let zombieColor = getTierColor(tier);

    // Drift flash: brief white flash when drift impulse fires.
    // Visual feedback so the player knows "that was drift, not me"
    // (Swink: closing the input -> simulation -> feedback loop).
    if (drift.flashTimer > 0) {
        const flashIntensity = drift.flashTimer / 0.15; // 1.0 -> 0.0
        // Blend toward white based on flash intensity
        zombieColor = `rgba(255, 255, 255, ${0.3 + 0.7 * flashIntensity})`;
    }

    ctx.fillStyle = zombieColor;
    ctx.fillRect(zombie.x, zombie.y, zombie.width, zombie.height);

    // Draw the tier color as an outline during flash so the zombie
    // doesn't become invisible — the flash overlays, not replaces
    if (drift.flashTimer > 0) {
        ctx.strokeStyle = getTierColor(tier);
        ctx.lineWidth = 2;
        ctx.strokeRect(zombie.x, zombie.y, zombie.width, zombie.height);
    }

    // "Z" label
    ctx.fillStyle = '#000';
    ctx.font = 'bold 18px Consolas, monospace';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText('Z', zombie.x + zombie.width / 2, zombie.y + zombie.height / 2);

    // --- Draw direction indicator (small arrow showing velocity) ---
    if (Math.abs(zombie.vx) > 10) {
        const arrowX = zombie.vx > 0
            ? zombie.x + zombie.width + 4
            : zombie.x - 8;
        const arrowDir = zombie.vx > 0 ? '>' : '<';
        ctx.fillStyle = zombieColor;
        ctx.font = '12px Consolas, monospace';
        ctx.textAlign = 'center';
        ctx.fillText(arrowDir, arrowX, zombie.y + zombie.height / 2);
    }
}

// ============================================================
// UI — DEBUG PANEL
// Real-time movement diagnostics. Updates every frame. This is
// the designer's primary tool for understanding why movement
// feels wrong (Koster: making the system's patterns visible).
// ============================================================

const debugPanel = document.getElementById('debug-panel');

function updateDebugPanel() {
    const tier = getSanityTier(sanity);
    const lines = [
        `Sanity: ${sanity.toFixed(1)} (${tier})`,
        `Velocity: (${zombie.vx.toFixed(0)}, ${zombie.vy.toFixed(0)})`,
        `Speed: ${Math.abs(zombie.vx).toFixed(0)} / ${getMaxSpeed().toFixed(0)}`,
        `Grounded: ${zombie.grounded}`,
        `Coyote: ${zombie.coyoteTimer.toFixed(2)}`,
        `Jump Buffer: ${zombie.jumpBufferTimer.toFixed(2)}`,
        `Air Control: ${getAirControl().toFixed(2)}`,
        `Drift Timer: ${drift.timer.toFixed(2)}`,
        `Drift Next: ${drift.nextInterval.toFixed(2)}`,
        `Jump Vel: ${getJumpVelocity().toFixed(0)}`,
        `Decel: ${getDeceleration().toFixed(0)}`,
    ];

    if (tier === 'Feral' && drift.inputDelayTimer > 0) {
        lines.push(`Input Delay: ${drift.inputDelayTimer.toFixed(3)}`);
    }

    debugPanel.textContent = lines.join('\n');
}

// ============================================================
// UI — SANITY SLIDER
// The star of the UI — lets the designer instantly feel the
// difference between tiers without code changes. Must be
// responsive and real-time (Schell Lens #18: Flow — UI must
// not interrupt the testing flow).
// ============================================================

const sanitySlider = document.getElementById('sanity-slider');
const sanityLabel = document.getElementById('sanity-label');
const goneOverlay = document.getElementById('gone-overlay');

sanitySlider.addEventListener('input', () => {
    sanity = parseFloat(sanitySlider.value);
    updateSanityUI();
});

function updateSanityUI() {
    const tier = getSanityTier(sanity);
    const color = getTierColor(tier);
    sanityLabel.textContent = `Sanity: ${sanity.toFixed(1)} (${tier})`;
    sanityLabel.style.color = color;

    // Gone overlay
    if (tier === 'Gone') {
        goneOverlay.classList.add('active');
    } else {
        goneOverlay.classList.remove('active');
    }
}

// ============================================================
// UI — TUNING PANEL
// Collapsible panel with sliders for all movement constants.
// Changes apply instantly — rapid iteration without editing
// code. Each slider writes directly to the corresponding let
// variable in the constants section.
// ============================================================

const tuningToggle = document.getElementById('tuning-toggle');
const tuningPanel = document.getElementById('tuning-panel');

tuningToggle.addEventListener('click', () => {
    tuningPanel.classList.toggle('open');
    tuningToggle.textContent = tuningPanel.classList.contains('open') ? 'Tuning ▼' : 'Tuning';
});

// Tuning parameter definitions: [label, variableName, min, max, step]
const tuningParams = [
    { section: 'Base Movement' },
    { label: 'Max Speed', key: 'BASE_MAX_SPEED', min: 100, max: 600, step: 10 },
    { label: 'Acceleration', key: 'BASE_ACCELERATION', min: 500, max: 3000, step: 50 },
    { label: 'Deceleration', key: 'BASE_DECELERATION', min: 500, max: 3000, step: 50 },
    { label: 'Air Control', key: 'BASE_AIR_CONTROL', min: 0, max: 1, step: 0.05 },

    { section: 'Jump' },
    { label: 'Jump Velocity', key: 'JUMP_VELOCITY', min: -800, max: -300, step: 10 },
    { label: 'Gravity', key: 'GRAVITY', min: 800, max: 2000, step: 50 },
    { label: 'Coyote Time', key: 'COYOTE_TIME', min: 0, max: 0.3, step: 0.01 },
    { label: 'Jump Buffer', key: 'JUMP_BUFFER_TIME', min: 0, max: 0.3, step: 0.01 },

    { section: 'Slipping Multipliers' },
    { label: 'Speed ×', key: 'SLIPPING_SPEED_MULT', min: 1.0, max: 2.0, step: 0.05 },
    { label: 'Accel ×', key: 'SLIPPING_ACCEL_MULT', min: 1.0, max: 2.0, step: 0.05 },
    { label: 'Air Ctrl ×', key: 'SLIPPING_AIR_CONTROL_MULT', min: 0.1, max: 1.0, step: 0.05 },

    { section: 'Feral Multipliers' },
    { label: 'Speed ×', key: 'FERAL_SPEED_MULT', min: 1.0, max: 3.0, step: 0.1 },
    { label: 'Accel ×', key: 'FERAL_ACCEL_MULT', min: 1.0, max: 3.0, step: 0.1 },
    { label: 'Air Ctrl ×', key: 'FERAL_AIR_CONTROL_MULT', min: 0.1, max: 1.0, step: 0.05 },

    { section: 'Drift' },
    { label: 'Slip Impulse', key: 'SLIPPING_DRIFT_IMPULSE', min: 10, max: 300, step: 10 },
    { label: 'Feral Impulse', key: 'FERAL_DRIFT_IMPULSE', min: 50, max: 500, step: 10 },
    { label: 'Airborne ×', key: 'DRIFT_AIRBORNE_MULT', min: 1.0, max: 4.0, step: 0.25 },
    { label: 'Feral Delay', key: 'FERAL_INPUT_DELAY', min: 0, max: 0.2, step: 0.01 },

    { section: 'Sanity Scaling' },
    { label: 'Feral Jump ×', key: 'FERAL_JUMP_MULT', min: 1.0, max: 2.0, step: 0.05 },
    { label: 'Feral Decel ×', key: 'FERAL_DECEL_MULT', min: 0.1, max: 1.0, step: 0.05 },
];

// We store references to the global variables via eval for live read/write.
// Architecture note: using eval here is acceptable because the keys are
// hardcoded string literals defined above — no user input reaches eval.
function buildTuningPanel() {
    let html = '';

    for (const param of tuningParams) {
        if (param.section) {
            html += `<div class="section-label">${param.section}</div>`;
            continue;
        }

        const currentVal = eval(param.key);
        const id = `tune-${param.key}`;
        html += `
            <label>
                <span>${param.label}</span>
                <input type="range" id="${id}" min="${param.min}" max="${param.max}"
                       step="${param.step}" value="${currentVal}"
                       data-key="${param.key}">
                <span id="${id}-val" style="min-width:45px;text-align:right">${currentVal}</span>
            </label>
        `;
    }

    // Level Generator section
    html += `<div class="section-label">Level Generator</div>`;
    html += `
        <label><span>Width</span>
            <input type="range" id="gen-width" min="20" max="60" step="1" value="${MAP_COLS}">
            <span id="gen-width-val" style="min-width:45px;text-align:right">${MAP_COLS}</span>
        </label>
        <label><span>Height</span>
            <input type="range" id="gen-height" min="15" max="35" step="1" value="${MAP_ROWS}">
            <span id="gen-height-val" style="min-width:45px;text-align:right">${MAP_ROWS}</span>
        </label>
        <label><span>Density</span>
            <input type="range" id="gen-density" min="10" max="90" step="5" value="50">
            <span id="gen-density-val" style="min-width:45px;text-align:right">0.5</span>
        </label>
        <label><span>Min Sanity</span>
            <input type="range" id="gen-sanity" min="1" max="12" step="1" value="7">
            <span id="gen-sanity-val" style="min-width:45px;text-align:right">7</span>
        </label>
        <label><span>Seed</span>
            <input type="number" id="gen-seed" value="42" class="gen-seed-input">
        </label>
        <div class="gen-button-row">
            <button onclick="doGenerate()">Generate</button>
            <button onclick="doRandomGenerate()">Random</button>
            <button onclick="loadPresetGauntlet()">Gauntlet</button>
        </div>
    `;

    tuningPanel.innerHTML = html;

    // Attach listeners for tuning sliders
    for (const param of tuningParams) {
        if (param.section) continue;
        const id = `tune-${param.key}`;
        const slider = document.getElementById(id);
        const valSpan = document.getElementById(`${id}-val`);

        slider.addEventListener('input', () => {
            const val = parseFloat(slider.value);
            // Write to the global variable
            eval(`${param.key} = ${val}`);
            valSpan.textContent = param.step < 1 ? val.toFixed(2) : val;
        });
    }

    // Attach listeners for generator sliders
    document.getElementById('gen-width').addEventListener('input', function() {
        document.getElementById('gen-width-val').textContent = this.value;
    });
    document.getElementById('gen-height').addEventListener('input', function() {
        document.getElementById('gen-height-val').textContent = this.value;
    });
    document.getElementById('gen-density').addEventListener('input', function() {
        document.getElementById('gen-density-val').textContent = (this.value / 100).toFixed(1);
    });
    document.getElementById('gen-sanity').addEventListener('input', function() {
        document.getElementById('gen-sanity-val').textContent = this.value;
    });
}

// ============================================================
// GAME LOOP
// Fixed-timestep-ish loop using requestAnimationFrame. We cap
// dt to 0.05s (20fps minimum) to prevent the "spiral of death"
// where large dt causes physics to explode, which causes even
// larger dt next frame.
// ============================================================

let lastTime = 0;

function gameLoop(currentTime) {
    const deltaTime = (currentTime - lastTime) / 1000;
    lastTime = currentTime;

    // Cap dt to prevent physics explosion on tab-switch or lag spike
    const dt = Math.min(deltaTime, 0.05);

    // Skip the first frame (deltaTime would be huge)
    if (deltaTime > 0 && deltaTime < 1) {
        processInput();
        updatePhysics(dt);
        updateDrift(dt);
        render();
        updateDebugPanel();
        updateSanityUI();
    }

    requestAnimationFrame(gameLoop);
}

// ============================================================
// INITIALIZATION
// Set up everything and start the loop. Canvas is already sized
// in the rendering section. Tuning panel is built dynamically.
// ============================================================

function init() {
    buildTuningPanel();
    updateSanityUI();
    findAndSetSpawn();
    requestAnimationFrame(gameLoop);
}

init();
</script>
</body>
</html>
