<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Zombie Movement Toy</title>
<style>
/* ============================================================
   STYLES
   Minimal styling — canvas-centric layout with UI overlay.
   ============================================================ */
* { margin: 0; padding: 0; box-sizing: border-box; }

body {
    background: #1a1a2e;
    display: flex;
    flex-direction: column;
    align-items: center;
    font-family: 'Segoe UI', Arial, sans-serif;
    color: #e0e0e0;
    overflow-x: hidden;
}

#game-container {
    position: relative;
    margin-top: 10px;
}

canvas {
    display: block;
    border: 2px solid #444;
    background: #16213e;
}

/* --- Sanity Slider (top bar) --- */
#sanity-bar {
    width: 100%;
    max-width: 1284px; /* updated dynamically by resizeCanvas() */
    padding: 8px 16px;
    background: #0f3460;
    display: flex;
    align-items: center;
    gap: 12px;
    border-radius: 0 0 6px 6px;
}

#sanity-bar label {
    font-weight: bold;
    font-size: 14px;
    white-space: nowrap;
    min-width: 180px;
}

#sanity-slider {
    flex: 1;
    height: 6px;
    cursor: pointer;
    accent-color: #53d769;
}

/* --- Debug Panel (overlaid on canvas) --- */
#debug-panel {
    position: absolute;
    top: 8px;
    right: 8px;
    background: rgba(0, 0, 0, 0.75);
    padding: 8px 12px;
    font-family: 'Consolas', 'Courier New', monospace;
    font-size: 12px;
    line-height: 1.5;
    color: #aaffaa;
    border-radius: 4px;
    pointer-events: none;
    white-space: pre;
    min-width: 200px;
}

/* --- Tuning Panel (collapsible side panel) --- */
#tuning-toggle {
    position: absolute;
    top: 8px;
    left: 8px;
    background: rgba(0, 0, 0, 0.75);
    color: #e0e0e0;
    border: 1px solid #555;
    padding: 4px 10px;
    font-size: 12px;
    cursor: pointer;
    border-radius: 4px;
    z-index: 10;
}
#tuning-toggle:hover { background: rgba(50, 50, 80, 0.9); }

#tuning-panel {
    position: absolute;
    top: 36px;
    left: 8px;
    background: rgba(0, 0, 0, 0.85);
    padding: 10px 14px;
    font-family: 'Consolas', 'Courier New', monospace;
    font-size: 11px;
    line-height: 1.8;
    color: #cccccc;
    border-radius: 4px;
    max-height: 750px;
    overflow-y: auto;
    width: 280px;
    display: none;
    z-index: 5;
}

#tuning-panel.open { display: block; }

#tuning-panel label {
    display: flex;
    justify-content: space-between;
    align-items: center;
    gap: 6px;
}

#tuning-panel input[type="range"] {
    width: 100px;
    height: 4px;
    cursor: pointer;
    accent-color: #53d769;
}

#tuning-panel .section-label {
    color: #ffcc00;
    font-weight: bold;
    margin-top: 6px;
    border-bottom: 1px solid #555;
    padding-bottom: 2px;
}

/* --- Gone overlay --- */
#gone-overlay {
    position: absolute;
    top: 0; left: 0; right: 0; bottom: 0;
    display: none;
    justify-content: center;
    align-items: center;
    background: rgba(0, 0, 0, 0.6);
    pointer-events: none;
    z-index: 20;
}
#gone-overlay.active { display: flex; }
#gone-overlay span {
    font-size: 64px;
    font-weight: bold;
    color: #ff3333;
    text-shadow: 0 0 30px #ff0000, 0 0 60px #880000;
    font-family: 'Consolas', monospace;
    letter-spacing: 8px;
}

/* --- Level Generator controls in tuning panel --- */
.gen-seed-input {
    width: 70px;
    background: #0a0a1a;
    border: 1px solid #555;
    color: #e0e0e0;
    padding: 3px 6px;
    font-family: 'Consolas', monospace;
    font-size: 11px;
    border-radius: 3px;
    text-align: right;
}
.gen-button-row {
    display: flex;
    gap: 4px;
    margin: 6px 0;
}
.gen-button-row button {
    flex: 1;
    background: #1a1a3e;
    color: #e0e0e0;
    border: 1px solid #555;
    padding: 4px 8px;
    font-family: 'Consolas', monospace;
    font-size: 11px;
    cursor: pointer;
    border-radius: 3px;
}
.gen-button-row button:hover { background: #2a2a5e; border-color: #53d769; }

/* --- Controls hint --- */
#controls-hint {
    margin-top: 8px;
    font-size: 12px;
    color: #888;
    text-align: center;
}
</style>
</head>
<body>

<div id="sanity-bar">
    <label id="sanity-label">Sanity: 12.0 (Lucid)</label>
    <input type="range" id="sanity-slider" min="0" max="12" step="0.1" value="12">
</div>

<div id="game-container">
    <canvas id="game-canvas"></canvas>
    <div id="debug-panel"></div>
    <button id="tuning-toggle">Tuning</button>
    <div id="tuning-panel"></div>
    <div id="gone-overlay"><span>MIND LOST</span></div>
</div>

<div id="controls-hint">
    WASD or Arrow Keys to move &bull; Space to jump &bull; Slider to change sanity tier
</div>

<script>
// ============================================================
// TUNABLE CONSTANTS
// All movement parameters live here. The tuning panel reads and
// writes these at runtime. Values sourced from paper prototype
// MC simulations (zombie-platformer repo docs/GDD.md).
// ============================================================

// --- Base movement (Lucid tier) ---
let BASE_MAX_SPEED = 300;          // px/s — top horizontal speed
let BASE_ACCELERATION = 2400;      // px/s² — how fast we reach max speed (was 1800, bumped for snappier starts)
let BASE_DECELERATION = 3200;      // px/s² — friction when no input
let BASE_AIR_CONTROL = 0.8;        // multiplier on accel while airborne

// --- Jump ---
let JUMP_VELOCITY = -600;          // px/s — initial upward velocity (negative = up)
let GRAVITY = 1400;                // px/s² — downward pull
let COYOTE_TIME = 0.1;            // seconds — grace period after leaving ground
let JUMP_BUFFER_TIME = 0.1;       // seconds — pre-landing jump input memory

// --- Sanity sliding scales ---
// ALL movement parameters interpolate smoothly across sanity 0-12.
// At sanity 12 the zombie gets base values; at sanity 0 it gets
// the FERAL_*_MULT × base. Linear interpolation between. This
// eliminates dead zones where the slider does nothing (playtest
// finding: tier-stepped values made the progression feel flat).
let FERAL_SPEED_MULT = 1.5;       // max speed at sanity 0
let FERAL_ACCEL_MULT = 1.6;       // acceleration at sanity 0
let FERAL_AIR_CONTROL_MULT = 0.5; // air control at sanity 0 (0.8 * 0.5 = 0.4)
let FERAL_JUMP_MULT = 1.6;        // jump strengthens as sanity drops
let FERAL_DECEL_MULT = 0.5;       // friction weakens as sanity drops (more slidey)
let FERAL_GRAVITY_MULT = 1.15;    // gravity increases as sanity drops (tighter arc, less floaty)

// --- Input drift (smooth system) ---
// Drift is the Thrill of Danger mechanic (Garneau/Heeter). Drift
// impulse and interval now interpolate smoothly via getSanityT()
// instead of stepping at tier boundaries. This eliminates the
// "Lucid free zone" (sanity 7-12 was zero cost) and the "Feral
// cliff" (28× cost increase for 5.6% gain at the 4→3.99 boundary).
//
// Impulse uses a squared curve (t²) so drift starts very gently
// at high sanity and accelerates into devastating at low sanity.
// Position nudge + velocity residue replaces pure velocity impulse
// so both same-direction and reverse drift are visible.
let DRIFT_BASE_IMPULSE = 500;            // max impulse (px/s equivalent) at sanity 0
let DRIFT_MIN_INTERVAL = 0.8;            // shortest interval between drifts (at sanity 0)
let DRIFT_MAX_INTERVAL = 5.0;            // longest interval (at sanity 12, effectively never)
let DRIFT_IMPULSE_EXPONENT = 2;          // curve shape: higher = gentler start, sharper end
let DRIFT_AIRBORNE_MULT = 2.0;           // impulse multiplier while not grounded
let DRIFT_NUDGE_SCALE = 0.1;             // px displacement per px/s of impulse (position nudge)
let DRIFT_VELOCITY_RESIDUE = 0.3;        // fraction of impulse applied as velocity change

// --- Input delay (smooth onset) ---
// Direction reversal delay now starts at sanity 6 (INPUT_DELAY_ONSET_T = 0.5)
// and scales to full at sanity 0. Previously only existed at Feral tier.
let FERAL_INPUT_DELAY = 0.03;            // max delay at sanity 0 (seconds)
let INPUT_DELAY_ONSET_T = 0.5;           // getSanityT() threshold where delay begins (sanity 6)

// --- Juice / feedback ---
// Feedback parameters for squash/stretch, particles, shake, and
// vignette. These close Swink's simulation → feedback loop so
// player actions feel alive instead of just moving a rectangle.
let SCALE_LERP_RATE = 12;               // how fast squash/stretch returns to 1.0 (per second)
let JUMP_SQUASH_X = 1.15;               // horizontal stretch on jump launch
let JUMP_SQUASH_Y = 0.80;               // vertical compress on jump launch
let LAND_STRETCH_MAX_Y = 0.20;          // max vertical stretch on landing (added to 1.0)
let LAND_SQUASH_MAX_X = 0.12;           // max horizontal compress on landing (subtracted from 1.0)
let LAND_VY_SCALE = 3000;               // vy divisor for landing intensity (higher = less intense)
let LANDING_SHAKE_MIN_VY = 400;         // minimum vy to trigger landing screen shake
let LANDING_SHAKE_INTENSITY = 4;        // max shake pixels for heaviest landing
let REVERSAL_SQUASH_X = 0.90;           // horizontal compress on high-speed direction reversal
let REVERSAL_MIN_SPEED = 200;           // minimum |vx| before reversal to trigger dust/squash
let PARTICLE_GRAVITY = 100;             // px/s² downward on dust particles
let VIGNETTE_MAX_OPACITY = 0.25;        // max vignette opacity at sanity 0
let SPEED_LINE_THRESHOLD = 0.8;         // fraction of max speed to start showing lines
let SPEED_LINE_OPACITY = 0.3;           // max opacity of speed lines
let PACING_ENABLED = true;
let PACING_DIFFICULTY_SCALE = 1.0;      // 0.5=easier, 1.5=harder

// ============================================================
// TILE MAP
// "Sanity Gauntlet" — 40 x 25 tiles. Designed so platforms are
// IMPOSSIBLE at full Lucid (sanity 12) and require progressively
// lower sanity to reach. Forces the player to trade control for
// ability, testing the core design tension.
//
// Jump peaks by sanity (FERAL_JUMP_MULT = 1.6):
//   Sanity 12 (Lucid):    peak ~129px (4 tiles)
//   Sanity  9 (Lucid):    peak ~170px (5.3 tiles)
//   Sanity  5 (Slipping): peak ~234px (7.3 tiles)
//   Sanity  3 (Feral):    peak ~270px (8.4 tiles)
//   Sanity  1 (Feral):    peak ~309px (9.7 tiles)
//
// Tier layout (gap from tier below):
//   Ground  = row 24 (runway, any sanity)
//   Lucid   = row 21 (3 rows up — easy at sanity 12)
//   Slip    = row 16 (5 rows up — needs sanity ≤ 9)
//   Feral   = row  8 (8 rows up — needs sanity ≤ 3)
//   Summit  = row  2 (6 rows up — already Feral, easy)
//
// Row 21 also has a 10-tile horizontal gap: Lucid max range
// is ~8 tiles, so the gap requires Feral speed to cross.
// ============================================================

const TILE_SIZE = 32;
let MAP_COLS = 40;
let MAP_ROWS = 25;

const PRESET_GAUNTLET = [
    '........................................', // row 0
    '........................................', // row 1
    '......====......====....................', // row 2  Summit
    '........................................', // row 3
    '........................................', // row 4
    '........................................', // row 5
    '........................................', // row 6
    '........................................', // row 7
    '..====..............====..........====..', // row 8  Feral zone
    '........................................', // row 9
    '........................................', // row 10
    '........................................', // row 11
    '........................................', // row 12
    '........................................', // row 13
    '........................................', // row 14
    '........................................', // row 15
    '====..........====..........====........', // row 16 Slipping zone
    '........................................', // row 17
    '........................................', // row 18
    '........................................', // row 19
    '........................................', // row 20
    '....====..====..====..........====..====', // row 21 Lucid zone (10-tile gap)
    '........................................', // row 22
    '........................................', // row 23
    '========================================', // row 24 Ground (runway)
];

let MAP_DATA = [...PRESET_GAUNTLET];

// Parse map into a 2D boolean grid: true = solid tile
let tileMap = MAP_DATA.map(row =>
    Array.from(row).map(ch => ch === '=')
);

// ============================================================
// LEVEL GENERATOR
// Procedural physics-aware platform generation. Calculates the
// jump envelope from the actual physics constants, builds
// layers bottom-up, adds stepping stones, then validates
// reachability via BFS.
// ============================================================

/** Seeded PRNG (splitmix32) — returns a function producing 0..1 floats */
function splitmix32(seed) {
    let s = seed | 0;
    return function() {
        s |= 0;
        s = s + 0x9e3779b9 | 0;
        let t = s ^ (s >>> 16);
        t = Math.imul(t, 0x21f0aaad);
        t = t ^ (t >>> 15);
        t = Math.imul(t, 0x735a2d97);
        t = t ^ (t >>> 15);
        return (t >>> 0) / 4294967296;
    };
}

/** Calculate jump envelope from real physics constants at a given sanity */
function calcJumpEnvelope(san) {
    // Smooth interpolation: t=0 at sanity 12, t=1 at sanity 0
    const t = Math.max(0, Math.min(1, (12 - san) / 12));
    const jumpVel = Math.abs(JUMP_VELOCITY * (1 + t * (FERAL_JUMP_MULT - 1)));

    // Gravity also scales with sanity
    const grav = GRAVITY * (1 + t * (FERAL_GRAVITY_MULT - 1));

    // Peak height from kinematics: h = v² / (2g)
    const peakPx = (jumpVel * jumpVel) / (2 * grav);
    const maxUpTiles = Math.floor(peakPx / TILE_SIZE);

    // Horizontal range at peak: time_to_peak = v/g, distance = speed * time
    const maxSpeed = BASE_MAX_SPEED * (1 + t * (FERAL_SPEED_MULT - 1));
    const timeToPeak = jumpVel / grav;
    const horizPx = maxSpeed * timeToPeak;
    const maxAcrossTiles = Math.floor(horizPx / TILE_SIZE);

    return { maxUpTiles, maxAcrossTiles };
}

/** Quick pairwise reachability check (elliptical envelope) */
function canReachPlatform(ax, ay, bx, by, maxUp, maxAcross) {
    const dx = Math.abs(bx - ax);
    const dy = ay - by; // positive = jumping up
    if (dy <= 0) return dx <= maxAcross + 1;
    return (dx / (maxAcross + 1)) ** 2 + (dy / (maxUp + 0.5)) ** 2 <= 1;
}

/** BFS reachability validation — removes platforms unreachable from ground */
function validateReachability(grid, w, h, maxUp, maxAcross) {
    const groundY = h - 1;

    function solid(x, y) {
        if (x < 0 || x >= w || y < 0 || y >= h) return true;
        return grid[y][x];
    }
    function canStand(x, y) {
        if (solid(x, y)) return false;
        return y === h - 1 || solid(x, y + 1);
    }
    function gravity(x, y) {
        while (y < h - 1 && !solid(x, y + 1)) y++;
        if (solid(x, y)) return null;
        return { x, y };
    }

    const reachable = new Set();
    const visited = new Set();
    const queue = [];

    // Seed from ground-level standing positions
    for (let x = 0; x < w; x++) {
        for (let y = groundY - 2; y <= groundY; y++) {
            if (y >= 0 && canStand(x, y)) {
                const key = `${x},${y}`;
                if (!visited.has(key)) {
                    visited.add(key);
                    queue.push({ x, y });
                }
            }
        }
    }

    while (queue.length > 0) {
        const cur = queue.shift();
        reachable.add(`${cur.x},${cur.y}`);
        const moves = [];

        // Horizontal moves
        for (const dx of [-1, 1]) {
            const nx = cur.x + dx;
            if (!solid(nx, cur.y)) {
                const landed = gravity(nx, cur.y);
                if (landed) moves.push(landed);
            }
        }

        // Jumps
        if (canStand(cur.x, cur.y)) {
            for (let jumpH = 1; jumpH <= maxUp; jumpH++) {
                const upY = cur.y - jumpH;
                let clear = true;
                for (let cy = 1; cy <= jumpH; cy++) {
                    if (solid(cur.x, cur.y - cy)) { clear = false; break; }
                }
                if (!clear) break;

                const landed = gravity(cur.x, upY);
                if (landed && (landed.x !== cur.x || landed.y !== cur.y)) moves.push(landed);

                for (const ddx of [-1, 1]) {
                    for (let reach = 1; reach <= maxAcross; reach++) {
                        const ax = cur.x + ddx * reach;
                        let hClear = true;
                        for (let r = 1; r <= reach; r++) {
                            if (solid(cur.x + ddx * r, upY)) { hClear = false; break; }
                        }
                        if (!hClear) break;
                        const landed2 = gravity(ax, upY);
                        if (landed2) moves.push(landed2);
                    }
                }
            }
        }

        for (const m of moves) {
            const key = `${m.x},${m.y}`;
            if (!visited.has(key)) {
                visited.add(key);
                queue.push(m);
            }
        }
    }

    // Remove platform tiles where the standing surface is unreachable
    for (let y = 1; y < h - 1; y++) {
        for (let x = 1; x < w - 1; x++) {
            if (!grid[y][x]) continue;
            if (y === 0) continue;
            if (!canStand(x, y - 1)) continue;
            if (!reachable.has(`${x},${y - 1}`)) {
                grid[y][x] = false;
            }
        }
    }
}

/** Place a row of solid tiles, clamped to playable area */
function placeRow(grid, y, x1, x2, width) {
    for (let x = Math.max(1, x1); x <= Math.min(width - 2, x2); x++) {
        grid[y][x] = true;
    }
}

// --- PACING DATA TABLES ---
const PACING_BEATS = {
    3: [
        { beat: 'hook',       difficulty: 0.5 },
        { beat: 'climax',     difficulty: 0.9 },
        { beat: 'resolution', difficulty: 0.3 },
    ],
    4: [
        { beat: 'hook',       difficulty: 0.5 },
        { beat: 'rising',     difficulty: 0.6 },
        { beat: 'climax',     difficulty: 0.9 },
        { beat: 'resolution', difficulty: 0.3 },
    ],
    5: [
        { beat: 'hook',       difficulty: 0.5 },
        { beat: 'rising',     difficulty: 0.65 },
        { beat: 'valley',     difficulty: 0.25 },
        { beat: 'climax',     difficulty: 0.9 },
        { beat: 'resolution', difficulty: 0.3 },
    ],
};

// Weighted archetype preferences per beat (higher = more likely)
const BEAT_ARCHETYPE_WEIGHTS = {
    hook:       { canyon: 3, tower: 3, open: 1, corridor: 1, staircase: 2 },
    rising:     { canyon: 1, tower: 3, open: 1, corridor: 1, staircase: 3 },
    valley:     { canyon: 1, tower: 0, open: 3, corridor: 3, staircase: 1 },
    climax:     { canyon: 3, tower: 3, open: 1, corridor: 2, staircase: 2 },
    resolution: { canyon: 1, tower: 0, open: 3, corridor: 3, staircase: 1 },
};

/** Pick archetype via weighted random from beat preferences, no back-to-back */
function selectArchetype(beat, rng, lastType) {
    const weights = BEAT_ARCHETYPE_WEIGHTS[beat];
    const entries = Object.entries(weights).filter(([t, w]) => t !== lastType && w > 0);
    const total = entries.reduce((sum, [, w]) => sum + w, 0);
    let roll = rng() * total;
    for (const [type, w] of entries) {
        roll -= w;
        if (roll <= 0) return type;
    }
    return entries[entries.length - 1][0];
}

/** Place transition zone at section boundary: 3-tile ground + optional perch */
function applyTransitionZone(grid, leftSec, rightSec, groundY, width) {
    const bx = rightSec.sx;
    const clamp = (x) => Math.max(1, Math.min(x, width - 2));
    // 3 tiles of ground at boundary
    for (let x = bx - 1; x <= bx + 1; x++) grid[groundY][clamp(x)] = true;
    // Perch platform when difficulty delta is steep
    const delta = Math.abs((leftSec.difficulty || 0) - (rightSec.difficulty || 0));
    if (delta > 0.3 && groundY - 3 > 2) {
        placeRow(grid, groundY - 3, clamp(bx - 1), clamp(bx + 1), width);
    }
}

/** Random platform length with personality: mix of tiny, medium, and wide */
function randPlatLen(rng, density) {
    const roll = rng();
    if (roll < 0.25) return 1 + Math.floor(rng() * 2);                         // tiny: 1-2
    if (roll < 0.55) return 3 + Math.floor(rng() * 2);                         // medium: 3-4
    return 5 + Math.floor(rng() * Math.max(1, Math.round(3 * density)));       // wide: 5-7+
}

/** Generate a single section by archetype. difficulty 0-1 modulates parameters. */
function generateSection(grid, type, sx, ex, groundY, height, width, rng, density, maxUp, maxAcross, difficulty) {
    const d = typeof difficulty === 'number' ? difficulty : 0.5;
    const secW = ex - sx + 1;
    const clamp = (x) => Math.max(1, Math.min(x, width - 2));

    switch (type) {

        case 'canyon': {
            // Gap min width scales up with difficulty
            const minGap = 2 + Math.floor(d * 2);
            const gapW = minGap + Math.floor(rng() * Math.max(1, Math.min(maxAcross - 1, secW - 6) - minGap + 1));
            const gapMid = sx + Math.floor(secW / 2) + Math.floor(rng() * 3) - 1;
            const gs = clamp(gapMid - Math.floor(gapW / 2));
            const ge = clamp(gs + gapW - 1);

            for (let x = sx; x <= ex; x++) {
                if (x < gs || x > ge) grid[groundY][x] = true;
            }

            // Bridge height scales up with difficulty
            const bridgeY = groundY - Math.max(2, Math.floor(maxUp * (0.3 + d * 0.3)));
            if (bridgeY > 2) {
                placeRow(grid, bridgeY, gs - 1, ge + 1, width);
            }

            // Upper reward platform
            const upperY = bridgeY - Math.max(2, Math.floor(maxUp * 0.5));
            if (upperY > 2 && secW >= 8) {
                const midX = sx + Math.floor(secW / 2);
                const pLen = randPlatLen(rng, density);
                placeRow(grid, upperY, midX - Math.floor(pLen / 2), midX + Math.ceil(pLen / 2), width);
            }
            break;
        }

        case 'tower': {
            // Ground floor
            for (let x = sx; x <= ex; x++) grid[groundY][x] = true;

            // Vertical stack — step-up height increases with difficulty, platforms narrower
            const towerCenter = sx + Math.floor(secW / 2) + Math.floor(rng() * 3) - 1;
            let towerY = groundY;
            let tier = 0;
            const towerDensity = density * (1.2 - d * 0.6);
            while (true) {
                const baseStep = 2 + Math.floor(d * 1.5);
                const stepUp = baseStep + Math.floor(rng() * Math.max(1, maxUp - baseStep));
                const nextY = towerY - stepUp;
                if (nextY <= 2) break;

                const offset = (tier % 2 === 0)
                    ? -(1 + Math.floor(rng() * 2))
                    : (1 + Math.floor(rng() * 2));
                const pLen = randPlatLen(rng, towerDensity);
                const px = clamp(towerCenter + offset - Math.floor(pLen / 2));
                placeRow(grid, nextY, px, px + pLen - 1, width);

                towerY = nextY;
                tier++;
            }

            // Side approach platform
            const sideX = (towerCenter - sx > secW / 2) ? sx + 1 : ex - 4;
            const sLen = 3 + Math.floor(rng() * 3);
            const sideY = groundY - (2 + Math.floor(rng() * Math.max(1, maxUp - 2)));
            if (sideY > 2) {
                placeRow(grid, sideY, clamp(sideX), clamp(sideX + sLen - 1), width);
            }
            break;
        }

        case 'open': {
            // Ground coverage decreases with difficulty (75% at d=0, 43% at d=1)
            const groundProb = 0.75 - d * 0.32;
            let x = sx;
            while (x <= ex) {
                if (rng() < groundProb) {
                    const segLen = 3 + Math.floor(rng() * 5);
                    for (let gx = x; gx < Math.min(x + segLen, ex + 1); gx++) {
                        grid[groundY][gx] = true;
                    }
                    // Occasional raised bump
                    if (rng() < 0.3 && segLen > 3) {
                        const bLen = 2 + Math.floor(rng() * 2);
                        for (let bx = x + 1; bx < Math.min(x + 1 + bLen, ex + 1); bx++) {
                            grid[groundY - 1][bx] = true;
                        }
                    }
                    x += segLen;
                } else {
                    // Ground gap width scales up with difficulty
                    const maxGap = Math.min(3 + Math.floor(d * 2), maxAcross);
                    x += 1 + Math.floor(rng() * maxGap);
                }
            }

            // Scattered platforms at various heights — mix of sizes
            const platCount = 2 + Math.floor(rng() * 4);
            for (let p = 0; p < platCount; p++) {
                const px = sx + 1 + Math.floor(rng() * (secW - 2));
                const py = 3 + Math.floor(rng() * (groundY - 5));
                const pLen = randPlatLen(rng, density);
                placeRow(grid, py, clamp(px), clamp(px + pLen - 1), width);
            }
            break;
        }

        case 'corridor': {
            // Full ground with low ceiling — ceiling lower at high difficulty
            for (let x = sx; x <= ex; x++) grid[groundY][x] = true;

            const ceilHeight = 3 + Math.floor((1 - d) * 2);
            const ceilY = groundY - ceilHeight;
            for (let x = sx; x <= ex; x++) grid[ceilY][x] = true;

            // Fewer ceiling gaps at high difficulty
            const gapCount = 1 + Math.floor(rng() * Math.max(1, 3 - Math.floor(d * 2)));
            for (let g = 0; g < gapCount; g++) {
                const gx = sx + 1 + Math.floor(rng() * (secW - 4));
                const gLen = 2 + Math.floor(rng() * 2);
                for (let x = gx; x < Math.min(gx + gLen, ex + 1); x++) {
                    grid[ceilY][x] = false;
                }
            }

            // Upper platforms above the ceiling (risk/reward high path)
            const upperCount = 1 + Math.floor(rng() * 2);
            for (let u = 0; u < upperCount; u++) {
                const ux = sx + 1 + Math.floor(rng() * (secW - 4));
                const uy = ceilY - (2 + Math.floor(rng() * Math.max(1, maxUp - 2)));
                if (uy > 2) {
                    const uLen = randPlatLen(rng, density);
                    placeRow(grid, uy, clamp(ux), clamp(ux + uLen - 1), width);
                }
            }

            // More ground bumps at high difficulty
            if (rng() < 0.4 + d * 0.3) {
                const bx = sx + 1 + Math.floor(rng() * (secW - 4));
                const bLen = 2 + Math.floor(rng() * 3);
                for (let x = bx; x < Math.min(bx + bLen, ex + 1); x++) {
                    grid[groundY - 1][x] = true;
                }
            }
            break;
        }

        case 'staircase': {
            // Ascending or descending chain of platforms
            const ascending = rng() < 0.5;

            // Ground on the starting side
            const gStart = ascending ? sx : sx + Math.floor(secW * 0.5);
            const gEnd = ascending ? sx + Math.floor(secW * 0.5) : ex;
            for (let x = gStart; x <= gEnd; x++) grid[groundY][x] = true;

            // Rise and run scale up with difficulty, platforms narrower
            const stepCount = 3 + Math.floor(rng() * 3);
            let stepY = groundY;
            let stepX = ascending ? sx + 2 : ex - 2;
            const dir = ascending ? 1 : -1;
            const stairDensity = density * (1.1 - d * 0.4);

            for (let s = 0; s < stepCount; s++) {
                const riseMax = Math.max(1, Math.floor(maxUp * (0.3 + d * 0.2)));
                const rise = 1 + Math.floor(rng() * riseMax);
                const runMax = Math.max(1, maxAcross - 1 + Math.floor(d * 2));
                const run = 2 + Math.floor(rng() * runMax);
                stepY -= rise;
                stepX += dir * run;
                if (stepY <= 2 || stepX < sx + 1 || stepX > ex - 1) break;

                const pLen = randPlatLen(rng, stairDensity);
                placeRow(grid, stepY, clamp(stepX), clamp(stepX + pLen - 1), width);
            }
            break;
        }
    }
}

/** Inject 1-2 landmark features for visual identity */
function injectLandmarks(grid, width, height, groundY, rng, maxUp) {
    const count = 1 + Math.floor(rng() * 2);
    const types = ['pillar', 'floater', 'overhang'];

    for (let i = 0; i < count; i++) {
        const type = types[Math.floor(rng() * types.length)];

        switch (type) {
            case 'pillar': {
                // Tall 1-wide column rising from ground
                const px = 3 + Math.floor(rng() * (width - 6));
                const pillarH = 3 + Math.floor(rng() * 5);
                for (let dy = 1; dy <= pillarH && groundY - dy > 1; dy++) {
                    grid[groundY - dy][px] = true;
                }
                break;
            }
            case 'floater': {
                // Single floating tile in open space
                const fx = 3 + Math.floor(rng() * (width - 6));
                const fy = 3 + Math.floor(rng() * (height - 8));
                grid[fy][fx] = true;
                break;
            }
            case 'overhang': {
                // Hang 1-2 tiles below an existing platform edge
                for (let attempt = 0; attempt < 15; attempt++) {
                    const ox = 2 + Math.floor(rng() * (width - 4));
                    const oy = 3 + Math.floor(rng() * (height - 6));
                    if (grid[oy][ox] && oy + 1 < groundY && !grid[oy + 1][ox]) {
                        grid[oy + 1][ox] = true;
                        if (rng() < 0.5 && ox + 1 < width - 1 &&
                            grid[oy][ox + 1] && !grid[oy + 1][ox + 1]) {
                            grid[oy + 1][ox + 1] = true;
                        }
                        break;
                    }
                }
                break;
            }
        }
    }
}

/** Generate a level with the given parameters */
function generateLevel(width, height, density, minSanity, seed) {
    const rng = splitmix32(seed);
    const { maxUpTiles, maxAcrossTiles } = calcJumpEnvelope(minSanity);
    const groundY = height - 1;

    // Initialize empty grid with walls and ceiling
    const grid = [];
    for (let y = 0; y < height; y++) {
        grid[y] = [];
        for (let x = 0; x < width; x++) grid[y][x] = false;
    }
    for (let y = 0; y < height; y++) { grid[y][0] = true; grid[y][width - 1] = true; }
    for (let x = 0; x < width; x++) grid[0][x] = true;

    // --- SECTION-BASED GENERATION ---
    const archetypes = ['canyon', 'tower', 'open', 'corridor', 'staircase'];
    const sectionCount = Math.max(3, Math.min(5, Math.floor(width / 10)));
    const secW = Math.floor((width - 2) / sectionCount);

    const sections = [];
    let lastType = null;

    if (PACING_ENABLED) {
        // Pacing-aware sequencer: follow Schell's interest curve
        const beats = PACING_BEATS[sectionCount] || PACING_BEATS[5];
        for (let i = 0; i < sectionCount; i++) {
            const sx = 1 + i * secW;
            const ex = (i === sectionCount - 1) ? width - 2 : sx + secW - 1;
            const beat = beats[Math.min(i, beats.length - 1)];
            const type = selectArchetype(beat.beat, rng, lastType);
            const diff = Math.min(1.0, beat.difficulty * PACING_DIFFICULTY_SCALE);
            lastType = type;
            sections.push({ sx, ex, type, difficulty: diff });
        }
    } else {
        // Original random behavior (no pacing)
        for (let i = 0; i < sectionCount; i++) {
            const sx = 1 + i * secW;
            const ex = (i === sectionCount - 1) ? width - 2 : sx + secW - 1;
            let available = archetypes.filter(t => t !== lastType);
            const type = available[Math.floor(rng() * available.length)];
            lastType = type;
            sections.push({ sx, ex, type, difficulty: 0.5 });
        }
        // Guarantee at least one tower or canyon for vertical interest
        if (!sections.some(s => s.type === 'tower' || s.type === 'canyon')) {
            const idx = 1 + Math.floor(rng() * Math.max(1, sections.length - 2));
            sections[idx].type = rng() < 0.5 ? 'tower' : 'canyon';
        }
    }

    // Generate each section with its difficulty
    for (const sec of sections) {
        generateSection(grid, sec.type, sec.sx, sec.ex,
            groundY, height, width, rng, density, maxUpTiles, maxAcrossTiles, sec.difficulty);
    }

    // Transition zones at section boundaries
    for (let i = 1; i < sections.length; i++) {
        applyTransitionZone(grid, sections[i - 1], sections[i], groundY, width);
    }
    // Ensure first and last section edges have ground
    const first = sections[0], last = sections[sections.length - 1];
    grid[groundY][first.sx] = true;
    if (first.sx + 1 <= first.ex) grid[groundY][first.sx + 1] = true;
    grid[groundY][last.ex] = true;
    if (last.ex - 1 >= last.sx) grid[groundY][last.ex - 1] = true;

    // --- LANDMARKS ---
    injectLandmarks(grid, width, height, groundY, rng, maxUpTiles);

    // --- BFS REACHABILITY VALIDATION ---
    validateReachability(grid, width, height, maxUpTiles, maxAcrossTiles);

    return grid;
}

/** Resize canvas to match current map dimensions */
function resizeCanvas() {
    canvas.width = MAP_COLS * TILE_SIZE;
    canvas.height = MAP_ROWS * TILE_SIZE;
    document.getElementById('sanity-bar').style.maxWidth = (MAP_COLS * TILE_SIZE + 4) + 'px';
}

/** Find a valid spawn point and place the zombie there */
function findAndSetSpawn() {
    for (let col = 0; col < MAP_COLS; col++) {
        for (let row = MAP_ROWS - 1; row >= 0; row--) {
            if (!tileMap[row][col]) continue;
            const h1 = row - 1, h2 = row - 2;
            if (h1 >= 0 && !tileMap[h1][col] && h2 >= 0 && !tileMap[h2][col]) {
                zombie.x = col * TILE_SIZE;
                zombie.y = row * TILE_SIZE - zombie.height;
                zombie.vx = 0;
                zombie.vy = 0;
                zombie.grounded = false;
                return;
            }
        }
    }
}

/** Apply a generated grid as the active level */
function applyLevel(grid, width, height) {
    MAP_COLS = width;
    MAP_ROWS = height;
    tileMap = grid;
    // Build MAP_DATA strings for consistency
    MAP_DATA = grid.map(row => row.map(v => v ? '=' : '.').join(''));
    resizeCanvas();
    findAndSetSpawn();
}

/** Restore the hardcoded Sanity Gauntlet map */
function loadPresetGauntlet() {
    MAP_COLS = 40;
    MAP_ROWS = 25;
    MAP_DATA = [...PRESET_GAUNTLET];
    tileMap = MAP_DATA.map(row => Array.from(row).map(ch => ch === '='));
    resizeCanvas();
    findAndSetSpawn();
    // Update generator sliders to match
    const ws = document.getElementById('gen-width');
    const hs = document.getElementById('gen-height');
    if (ws) { ws.value = 40; document.getElementById('gen-width-val').textContent = '40'; }
    if (hs) { hs.value = 25; document.getElementById('gen-height-val').textContent = '25'; }
}

/** UI: Generate level with current slider values */
function doGenerate() {
    const width = parseInt(document.getElementById('gen-width').value);
    const height = parseInt(document.getElementById('gen-height').value);
    const density = parseInt(document.getElementById('gen-density').value) / 100;
    const minSanity = parseInt(document.getElementById('gen-sanity').value);
    const seed = parseInt(document.getElementById('gen-seed').value) || 42;
    const grid = generateLevel(width, height, density, minSanity, seed);
    applyLevel(grid, width, height);
}

/** UI: Random seed then generate */
function doRandomGenerate() {
    const seed = Math.floor(Math.random() * 999999);
    document.getElementById('gen-seed').value = seed;
    doGenerate();
}

// ============================================================
// GAME STATE
// Mutable runtime state. Kept separate from constants so the
// tuning panel only touches the constants section above.
// ============================================================

const zombie = {
    x: 32,              // spawn position — bottom left, one tile in
    y: (MAP_ROWS - 2) * TILE_SIZE,  // one tile above ground
    width: 32,
    height: 48,
    vx: 0,
    vy: 0,
    grounded: false,
    coyoteTimer: 0,      // time since last grounded (for coyote time)
    jumpBufferTimer: 0,  // time since jump was pressed (for jump buffering)
    wasGrounded: false,   // grounded state from previous frame
    jumpCut: false,       // true after variable-height cut fires (prevents repeated cuts)
    scaleX: 1,            // squash/stretch horizontal (1.0 = normal)
    scaleY: 1,            // squash/stretch vertical (1.0 = normal)
    lastVy: 0,            // vy at moment of landing (for intensity scaling)
};

let sanity = 12;

// Input state
const input = {
    left: false,
    right: false,
    jump: false,
    jumpPressed: false,   // true only on the frame jump is first pressed
    jumpHeld: false,      // true while jump key is held
};

// Drift state
const drift = {
    timer: 0,
    nextInterval: 1.0,    // seconds until next drift impulse
    inputDelayTimer: 0,   // Feral-only: remaining input delay
    inputDelayDirection: 0, // which direction was blocked (-1 left, 1 right, 0 none)
    flashTimer: 0,        // visual feedback: counts down after drift fires
    flashDirection: 0,    // which side drift pushed toward (-1 left, 1 right)
    lastImpulse: 0,       // magnitude of most recent drift impulse (for rendering)
};

// Juice state — particles, camera shake
// Architecture note: particles are a flat array rather than a linked
// list because the count is small (< 30 at any time) and array
// iteration is cache-friendly. Camera shake uses exponential decay
// for natural-feeling falloff.
const particles = [];
const camera = {
    shakeX: 0,
    shakeY: 0,
    shakeIntensity: 0,
    shakeDuration: 0,
    shakeTimer: 0,
    shakeBiasX: 0,        // directional bias (-1 left, 0 neutral, 1 right)
};

// ============================================================
// SANITY TIER HELPERS
// Tier boundaries from paper prototype: Lucid >= 7, Slipping
// 4-6.99, Feral 0.01-3.99, Gone = 0. These thresholds match
// the validated MC simulation parameters.
// ============================================================

function getSanityTier(s) {
    if (s <= 0) return 'Gone';
    if (s < 4) return 'Feral';
    if (s < 7) return 'Slipping';
    return 'Lucid';
}

function getTierColor(tier) {
    switch (tier) {
        case 'Lucid':    return '#53d769'; // green
        case 'Slipping': return '#ffcc00'; // yellow
        case 'Feral':    return '#ff6b35'; // orange
        case 'Gone':     return '#ff3333'; // red
    }
}

function getMaxSpeed() {
    const t = getSanityT();
    return BASE_MAX_SPEED * (1 + t * (FERAL_SPEED_MULT - 1));
}

function getAcceleration() {
    const t = getSanityT();
    let accel = BASE_ACCELERATION * (1 + t * (FERAL_ACCEL_MULT - 1));

    // Reduce acceleration while airborne (air control)
    if (!zombie.grounded) {
        accel *= getAirControl();
    }
    return accel;
}

// Sanity sliding scales share a common interpolation factor:
// t = 0 at sanity 12 (Lucid), t = 1 at sanity 0 (Gone).
function getSanityT() {
    return Math.max(0, Math.min(1, (12 - sanity) / 12));
}

// Deceleration weakens as sanity drops — the zombie can't stop
// its own momentum. Creates the "committed to a direction" feel
// at low sanity (Swink: simulation weight).
function getDeceleration() {
    const t = getSanityT();
    return BASE_DECELERATION * (1 + t * (FERAL_DECEL_MULT - 1));
}

// Jump strengthens as sanity drops — the feral zombie is more
// explosive. Smooth scale, not stepped by tier.
function getJumpVelocity() {
    const t = getSanityT();
    return JUMP_VELOCITY * (1 + t * (FERAL_JUMP_MULT - 1));
}

function getAirControl() {
    const t = getSanityT();
    return BASE_AIR_CONTROL * (1 + t * (FERAL_AIR_CONTROL_MULT - 1));
}

// Gravity increases as sanity drops — tighter jump arcs at low
// sanity so Feral feels punchy, not floaty (playtest finding).
function getGravity() {
    const t = getSanityT();
    return GRAVITY * (1 + t * (FERAL_GRAVITY_MULT - 1));
}

// Drift impulse: t² curve — gentle at high sanity, devastating at low.
// At sanity 12: 0. At sanity 7: ~87. At sanity 3: ~281. At sanity 0: 500.
function getDriftImpulse() {
    const t = getSanityT();
    return DRIFT_BASE_IMPULSE * Math.pow(t, DRIFT_IMPULSE_EXPONENT);
}

// Drift interval: linear from MAX_INTERVAL at sanity 12 to MIN at sanity 0.
function getDriftInterval() {
    const t = getSanityT();
    return DRIFT_MAX_INTERVAL - (DRIFT_MAX_INTERVAL - DRIFT_MIN_INTERVAL) * t;
}

// Input delay: 0 above onset threshold, scales to FERAL_INPUT_DELAY at sanity 0.
function getInputDelay() {
    const t = getSanityT();
    if (t <= INPUT_DELAY_ONSET_T) return 0;
    return FERAL_INPUT_DELAY * (t - INPUT_DELAY_ONSET_T) / (1 - INPUT_DELAY_ONSET_T);
}

// ============================================================
// INPUT HANDLING
// Tracks key state for movement and jump. Supports both WASD
// and arrow keys. Jump uses both space and W/Up for convenience.
// Architecture note: we track jumpPressed (edge) separately
// from jumpHeld (level) because variable jump height needs to
// know when the key is released, while jump buffering needs to
// know when it was first pressed.
// ============================================================

const keysDown = new Set();

window.addEventListener('keydown', (e) => {
    if (['ArrowLeft', 'ArrowRight', 'ArrowUp', 'ArrowDown',
         'a', 'd', 'w', 's', ' '].includes(e.key)) {
        e.preventDefault();
    }
    if (!keysDown.has(e.key)) {
        keysDown.add(e.key);
        // Edge-triggered jump detection
        if (e.key === ' ' || e.key === 'w' || e.key === 'W' || e.key === 'ArrowUp') {
            input.jumpPressed = true;
        }
    }
});

window.addEventListener('keyup', (e) => {
    keysDown.delete(e.key);
});

// Prevent stuck keys when window loses focus
window.addEventListener('blur', () => {
    keysDown.clear();
});

function processInput() {
    input.left = keysDown.has('ArrowLeft') || keysDown.has('a') || keysDown.has('A');
    input.right = keysDown.has('ArrowRight') || keysDown.has('d') || keysDown.has('D');
    input.jumpHeld = keysDown.has(' ') || keysDown.has('w') || keysDown.has('W') || keysDown.has('ArrowUp');
    // jumpPressed is consumed after use — set in keydown handler, cleared in updateJump
}

// ============================================================
// PHYSICS UPDATE
// Core movement loop. Frame-rate independent via dt. The update
// order matters: gravity -> input accel -> friction -> clamp ->
// position -> collision -> jump timers. This order prevents
// a frame of clipping after position update by resolving
// collisions before the next render.
// ============================================================

function updatePhysics(dt) {
    const tier = getSanityTier(sanity);

    // --- Gone tier: no movement ---
    if (tier === 'Gone') {
        zombie.vx = 0;
        zombie.vy = 0;
        return;
    }

    // --- Gravity ---
    zombie.vy += getGravity() * dt;

    // --- Horizontal input ---
    // Input delay: when reversing direction at low sanity, block input
    // briefly. Starts at sanity 6 (INPUT_DELAY_ONSET_T = 0.5), scales
    // smoothly to full at sanity 0. Makes momentum feel more committal
    // as the zombie loses its mind (Swink: simulation weight).
    let effectiveLeft = input.left;
    let effectiveRight = input.right;

    if (drift.inputDelayTimer > 0) {
        drift.inputDelayTimer -= dt;
        if (drift.inputDelayDirection === -1) effectiveLeft = false;
        if (drift.inputDelayDirection === 1) effectiveRight = false;
    }

    // Check for direction reversal to trigger input delay (smooth onset)
    const currentDelay = getInputDelay();
    if (currentDelay > 0) {
        if (effectiveLeft && zombie.vx > 50) {
            drift.inputDelayTimer = currentDelay;
            drift.inputDelayDirection = -1;
            effectiveLeft = false;
        } else if (effectiveRight && zombie.vx < -50) {
            drift.inputDelayTimer = currentDelay;
            drift.inputDelayDirection = 1;
            effectiveRight = false;
        }
    }

    // --- Detect high-speed direction reversal for juice ---
    // Capture vx sign BEFORE acceleration so we can detect when
    // input reverses the zombie's direction this frame.
    const prevVxSign = Math.sign(zombie.vx);
    const prevVxAbs = Math.abs(zombie.vx);

    const accel = getAcceleration();
    if (effectiveLeft)  zombie.vx -= accel * dt;
    if (effectiveRight) zombie.vx += accel * dt;

    // --- Friction (deceleration when no horizontal input) ---
    if (!effectiveLeft && !effectiveRight) {
        const friction = getDeceleration() * dt;
        if (zombie.vx > 0)      zombie.vx = Math.max(0, zombie.vx - friction);
        else if (zombie.vx < 0) zombie.vx = Math.min(0, zombie.vx + friction);
    }

    // --- Clamp to max speed ---
    const maxSpeed = getMaxSpeed();
    zombie.vx = Math.max(-maxSpeed, Math.min(maxSpeed, zombie.vx));

    // --- Update position and resolve collisions per-axis ---
    // Moving and resolving one axis at a time prevents the bug where
    // pressing into a wall causes the zombie's x to overlap the wall
    // column, and the ceiling check sees the wall tile and kills the
    // jump. By resolving X first, the zombie's horizontal position is
    // corrected before any vertical checks run.
    zombie.x += zombie.vx * dt;
    clampWorldBoundsX();
    resolveHorizontal();

    // Save vy before vertical collision for landing intensity scaling
    zombie.lastVy = zombie.vy;

    zombie.y += zombie.vy * dt;
    clampWorldBoundsY();
    resolveVertical();

    // --- Reversal juice trigger ---
    // Fire when the zombie was moving fast in one direction and
    // acceleration reversed the sign this frame.
    const newVxSign = Math.sign(zombie.vx);
    if (prevVxSign !== 0 && newVxSign !== 0 && prevVxSign !== newVxSign
        && prevVxAbs > REVERSAL_MIN_SPEED) {
        zombie.scaleX = REVERSAL_SQUASH_X;
        if (zombie.grounded) {
            emitDust(zombie.x + zombie.width / 2, zombie.y + zombie.height,
                2, -prevVxSign * 40, 30);
        }
    }

    // --- Jump timers ---
    updateJumpTimers(dt);

    // --- Jump execution ---
    updateJump();
}

// ============================================================
// COLLISION DETECTION
// Simple AABB vs tile grid. Each axis is moved and resolved
// independently in updatePhysics: X first, then Y. This
// prevents the "wall eats jump" bug where unresolved horizontal
// overlap causes the ceiling check to see wall tiles.
//
// Ground detection uses zombie.y + zombie.height (feet pixel)
// instead of zombie.y + zombie.height - 1 (last body pixel).
// This fixes a flickering grounded state when the zombie is
// exactly 1.5 tiles tall and perfectly placed on a tile
// boundary — the last body pixel falls in the row above ground.
// ============================================================

function isSolid(col, row) {
    if (col < 0 || col >= MAP_COLS || row < 0 || row >= MAP_ROWS) return false;
    return tileMap[row][col];
}

function clampWorldBoundsX() {
    if (zombie.x < 0) {
        zombie.x = 0;
        zombie.vx = Math.max(0, zombie.vx);
    }
    if (zombie.x + zombie.width > MAP_COLS * TILE_SIZE) {
        zombie.x = MAP_COLS * TILE_SIZE - zombie.width;
        zombie.vx = Math.min(0, zombie.vx);
    }
}

function clampWorldBoundsY() {
    if (zombie.y < 0) {
        zombie.y = 0;
        zombie.vy = Math.max(0, zombie.vy);
    }
    if (zombie.y + zombie.height > MAP_ROWS * TILE_SIZE) {
        zombie.y = MAP_ROWS * TILE_SIZE - zombie.height;
        zombie.vy = 0;
        zombie.grounded = true;
    }
}

function resolveVertical() {
    const left = Math.floor(zombie.x / TILE_SIZE);
    const right = Math.floor((zombie.x + zombie.width - 1) / TILE_SIZE);

    zombie.grounded = false;

    if (zombie.vy >= 0) {
        // Falling or stationary — sense ground at feet.
        // Using zombie.y + zombie.height (not -1) so that when the
        // zombie is exactly on a tile boundary, we detect the tile
        // below its feet rather than the empty row its bottom pixel
        // occupies. This eliminates grounded flicker for non-tile-
        // aligned heights (e.g. 48px = 1.5 tiles).
        const feetRow = Math.floor((zombie.y + zombie.height) / TILE_SIZE);
        for (let col = left; col <= right; col++) {
            if (isSolid(col, feetRow)) {
                zombie.y = feetRow * TILE_SIZE - zombie.height;
                zombie.vy = 0;
                zombie.grounded = true;
                break;
            }
        }
    }

    if (zombie.vy < 0) {
        // Rising — check above
        const topRow = Math.floor(zombie.y / TILE_SIZE);
        for (let col = left; col <= right; col++) {
            if (isSolid(col, topRow)) {
                zombie.y = (topRow + 1) * TILE_SIZE;
                zombie.vy = 0;
                break;
            }
        }
    }
}

function resolveHorizontal() {
    const top = Math.floor(zombie.y / TILE_SIZE);
    const bottom = Math.floor((zombie.y + zombie.height - 1) / TILE_SIZE);

    if (zombie.vx > 0) {
        const rightCol = Math.floor((zombie.x + zombie.width - 1) / TILE_SIZE);
        for (let row = top; row <= bottom; row++) {
            if (isSolid(rightCol, row)) {
                zombie.x = rightCol * TILE_SIZE - zombie.width;
                zombie.vx = 0;
                break;
            }
        }
    }

    if (zombie.vx < 0) {
        const leftCol = Math.floor(zombie.x / TILE_SIZE);
        for (let row = top; row <= bottom; row++) {
            if (isSolid(leftCol, row)) {
                zombie.x = (leftCol + 1) * TILE_SIZE;
                zombie.vx = 0;
                break;
            }
        }
    }
}

// ============================================================
// JUMP SYSTEM
// Implements coyote time, jump buffering, and variable jump
// height. These three features are essential for responsive
// platformer feel (per Swink's input responsiveness model).
//
// Coyote time: after walking off a ledge, the player has a
//   brief window to still jump. Prevents "I was on the edge!"
// Jump buffer: pressing jump slightly before landing queues
//   the jump to fire on landing. Prevents "I pressed jump!"
// Variable height: releasing jump early cuts upward velocity,
//   giving short hops vs full jumps from one button.
// ============================================================

function updateJumpTimers(dt) {
    // --- Landing detection (before wasGrounded is overwritten) ---
    // Check grounded transition: was airborne last frame, grounded now.
    // This is the landing frame — trigger stretch, dust, and shake.
    if (zombie.grounded && !zombie.wasGrounded) {
        const landVy = Math.abs(zombie.lastVy);

        // Stretch on landing — intensity scales with fall speed
        const stretchY = 1.0 + Math.min(LAND_STRETCH_MAX_Y, landVy / LAND_VY_SCALE);
        const squashX = 1.0 - Math.min(LAND_SQUASH_MAX_X, landVy / (LAND_VY_SCALE * 1.5));
        zombie.scaleX = squashX;
        zombie.scaleY = stretchY;

        // Landing dust — more particles for harder landings
        const dustCount = Math.min(6, 2 + Math.floor(landVy / 400));
        emitDust(zombie.x + zombie.width / 2, zombie.y + zombie.height,
            dustCount, 0, 50 + landVy * 0.05);

        // Screen shake on heavy landings
        if (landVy > LANDING_SHAKE_MIN_VY) {
            const shakeIntensity = Math.min(LANDING_SHAKE_INTENSITY, landVy / 300);
            triggerShake(shakeIntensity, 0.08);
        }
    }

    zombie.wasGrounded = zombie.grounded;

    if (zombie.grounded) {
        zombie.coyoteTimer = 0;
    } else {
        zombie.coyoteTimer += dt;
    }

    if (input.jumpPressed) {
        zombie.jumpBufferTimer = JUMP_BUFFER_TIME;
        input.jumpPressed = false;
    } else {
        zombie.jumpBufferTimer = Math.max(0, zombie.jumpBufferTimer - dt);
    }
}

function updateJump() {
    const canJump = zombie.grounded || zombie.coyoteTimer < COYOTE_TIME;
    const wantsJump = zombie.jumpBufferTimer > 0;

    if (canJump && wantsJump) {
        zombie.vy = getJumpVelocity();
        zombie.grounded = false;
        zombie.coyoteTimer = COYOTE_TIME; // exhaust coyote time to prevent double jump
        zombie.jumpBufferTimer = 0;
        zombie.jumpCut = false; // reset cut flag for new jump

        // Jump launch squash — compress vertically, stretch horizontally.
        // Must happen on the SAME FRAME as the jump for responsiveness
        // (Swink: input → feedback latency must be zero).
        zombie.scaleX = JUMP_SQUASH_X;
        zombie.scaleY = JUMP_SQUASH_Y;

        // Dust burst at feet
        emitDust(zombie.x + zombie.width / 2, zombie.y + zombie.height,
            4, 0, 40);
    }

    // Variable jump height: releasing jump early cuts upward velocity (once)
    if (!input.jumpHeld && zombie.vy < 0 && !zombie.jumpCut) {
        zombie.vy *= 0.5;
        zombie.jumpCut = true;
    }
}

// ============================================================
// INPUT DRIFT (SMOOTH SYSTEM)
// Random horizontal impulses simulate the zombie's body fighting
// the player's intentions. This is the Thrill of Danger mechanic
// (Garneau/Heeter). Drift impulse and interval interpolate
// smoothly via getSanityT() — no tier boundaries, no cliffs.
//
// Impulse uses a t² curve: gentle at high sanity (barely
// perceptible nudges), devastating at low sanity (1+ tile shoves).
//
// Drift applies as a position nudge + velocity residue instead
// of pure velocity impulse. This makes BOTH directions visible:
// same-direction drift causes overshoot (pushed past your target),
// reverse drift causes undershoot. The speed clamp no longer eats
// same-direction drift (balance report finding: old system made
// 50% of drift events invisible).
//
// Airborne multiplier makes drift scariest mid-jump. Visual flash
// + directional shake + vignette scale with impulse strength.
// ============================================================

function updateDrift(dt) {
    // Tick down drift flash regardless of sanity
    if (drift.flashTimer > 0) drift.flashTimer -= dt;

    // Drift impulse from smooth curve (t² — gentle start, sharp end)
    const baseImpulse = getDriftImpulse();

    // Below threshold, drift is imperceptible — skip entirely
    if (baseImpulse < 5) {
        drift.timer = 0;
        return;
    }

    drift.timer += dt;

    if (drift.timer >= drift.nextInterval) {
        drift.timer = 0;

        let impulse = baseImpulse;

        // Airborne amplification — drift is scariest mid-jump
        if (!zombie.grounded) {
            impulse *= DRIFT_AIRBORNE_MULT;
        }

        // Random next interval (±30% around the smooth average)
        const avgInterval = getDriftInterval();
        drift.nextInterval = avgInterval * (0.7 + Math.random() * 0.6);
        drift.nextInterval = Math.max(DRIFT_MIN_INTERVAL, drift.nextInterval);

        // Apply drift: position nudge + velocity residue
        const direction = Math.random() < 0.5 ? -1 : 1;

        // Position nudge — instant displacement that bypasses speed clamp.
        // Both directions create observable movement: forward = overshoot,
        // backward = undershoot. Swept collision prevents tunneling through
        // tiles on large nudges (up to 100px at max airborne drift).
        const startX = zombie.x;
        zombie.x += direction * impulse * DRIFT_NUDGE_SCALE;
        clampWorldBoundsX();

        // Swept collision: check every column between old and new position
        // so the zombie can't teleport through solid tiles
        const cTop = Math.floor(zombie.y / TILE_SIZE);
        const cBot = Math.floor((zombie.y + zombie.height - 1) / TILE_SIZE);
        if (direction > 0) {
            const origCol = Math.floor((startX + zombie.width - 1) / TILE_SIZE);
            const newCol = Math.floor((zombie.x + zombie.width - 1) / TILE_SIZE);
            for (let c = origCol + 1; c <= newCol; c++) {
                let hit = false;
                for (let row = cTop; row <= cBot; row++) {
                    if (isSolid(c, row)) {
                        zombie.x = c * TILE_SIZE - zombie.width;
                        hit = true;
                        break;
                    }
                }
                if (hit) break;
            }
        } else {
            const origCol = Math.floor(startX / TILE_SIZE);
            const newCol = Math.floor(zombie.x / TILE_SIZE);
            for (let c = origCol - 1; c >= newCol; c--) {
                let hit = false;
                for (let row = cTop; row <= cBot; row++) {
                    if (isSolid(c, row)) {
                        zombie.x = (c + 1) * TILE_SIZE;
                        hit = true;
                        break;
                    }
                }
                if (hit) break;
            }
        }

        // Y resolution after X nudge — prevents falling off platform
        // edges when drift pushes zombie horizontally off ground
        resolveVertical();

        // Velocity residue — small momentum change for physical feel.
        // Gets corrected by acceleration/friction over the next few frames.
        zombie.vx += direction * impulse * DRIFT_VELOCITY_RESIDUE;

        // Visual feedback — all scale with impulse strength
        drift.flashTimer = 0.15;
        drift.flashDirection = direction;
        drift.lastImpulse = impulse;

        // Directional screen shake scales with impulse
        const shakeIntensity = Math.min(4, impulse / 100);
        if (shakeIntensity > 0.5) {
            triggerShake(shakeIntensity, 0.08, direction);
        }
    }
}

// ============================================================
// JUICE SYSTEMS
// Squash/stretch, particles, screen shake, and vignette. These
// close Swink's simulation → feedback loop. Without them, the
// movement system is mechanically correct but feels "dead."
//
// Architecture note: these are intentionally simple. A particle
// is 9 floats. Screen shake is a decaying offset. Squash/stretch
// is a lerp toward 1.0. No abstractions beyond what's needed —
// this is a toy, not an engine (Nystrom: YAGNI).
// ============================================================

/** Emit dust particles at a position. spreadX biases horizontal scatter. */
function emitDust(x, y, count, biasX, spread) {
    for (let i = 0; i < count; i++) {
        particles.push({
            x: x + (Math.random() - 0.5) * 10,
            y: y - 2,
            vx: biasX + (Math.random() - 0.5) * spread * 2,
            vy: -(20 + Math.random() * 40),
            life: 0.2 + Math.random() * 0.15,
            maxLife: 0.35,
            size: 3 + Math.random() * 3,
            color: '#999',
        });
    }
}

/** Trigger screen shake with intensity (pixels) and duration (seconds).
 *  Optional dirX biases shake toward a direction (-1 left, 1 right, 0 neutral). */
function triggerShake(intensity, duration, dirX) {
    // Use the stronger shake if multiple fire in the same window
    // (stacking with dampening, per Vlambeer's guidelines).
    // Directional bias follows the winning intensity.
    if (intensity > camera.shakeIntensity) {
        camera.shakeIntensity = intensity;
        camera.shakeBiasX = dirX || 0;
    }
    camera.shakeDuration = Math.max(camera.shakeDuration, duration);
    camera.shakeTimer = 0;
}

/** Update all juice systems each frame. */
function updateJuice(dt) {
    // --- Squash/stretch lerp toward 1.0 ---
    // Exponential approach: fast snap-back that settles smoothly.
    const lerpSpeed = SCALE_LERP_RATE * dt;
    zombie.scaleX += (1.0 - zombie.scaleX) * Math.min(1, lerpSpeed);
    zombie.scaleY += (1.0 - zombie.scaleY) * Math.min(1, lerpSpeed);

    // Clamp near 1.0 to avoid perpetual micro-oscillation
    if (Math.abs(zombie.scaleX - 1.0) < 0.005) zombie.scaleX = 1.0;
    if (Math.abs(zombie.scaleY - 1.0) < 0.005) zombie.scaleY = 1.0;

    // --- Particles ---
    for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        p.x += p.vx * dt;
        p.y += p.vy * dt;
        p.vy += PARTICLE_GRAVITY * dt;
        p.life -= dt;
        if (p.life <= 0) {
            particles.splice(i, 1);
        }
    }

    // --- Screen shake decay ---
    if (camera.shakeDuration > 0) {
        camera.shakeTimer += dt;
        if (camera.shakeTimer >= camera.shakeDuration) {
            camera.shakeDuration = 0;
            camera.shakeTimer = 0;
            camera.shakeIntensity = 0;
            camera.shakeBiasX = 0;
            camera.shakeX = 0;
            camera.shakeY = 0;
        } else {
            // Exponential decay: starts strong, fades out
            const progress = camera.shakeTimer / camera.shakeDuration;
            const decayedIntensity = camera.shakeIntensity * (1 - progress);
            // Random component + directional bias. Bias adds a constant
            // pull toward the drift direction so the world "lurches."
            camera.shakeX = (Math.random() - 0.5) * 2 * decayedIntensity
                + camera.shakeBiasX * decayedIntensity;
            camera.shakeY = (Math.random() - 0.5) * 2 * decayedIntensity;
        }
    }
}

/** Draw all active particles. Called during render. */
function renderParticles() {
    for (const p of particles) {
        const alpha = Math.max(0, p.life / p.maxLife);
        ctx.globalAlpha = alpha * 0.7;
        ctx.fillStyle = p.color;
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.size * alpha, 0, Math.PI * 2);
        ctx.fill();
    }
    ctx.globalAlpha = 1.0;
}

/** Draw speed lines behind the zombie when moving fast.
 *  Lines trail opposite to movement direction. Count and opacity
 *  ramp up as speed approaches max. Shimmer per frame via random
 *  y-offsets communicates sustained velocity (Celeste-style). */
function renderSpeedLines() {
    const speed = Math.abs(zombie.vx);
    const maxSpeed = getMaxSpeed();
    const threshold = maxSpeed * SPEED_LINE_THRESHOLD;
    if (speed < threshold || threshold >= maxSpeed) return;

    // 0→1 ramp from threshold to max speed
    const intensity = Math.min(1, (speed - threshold) / (maxSpeed - threshold));
    const tier = getSanityTier(sanity);
    const color = getTierColor(tier);
    const dir = zombie.vx > 0 ? -1 : 1; // trail opposite to movement
    const startX = dir > 0 ? zombie.x + zombie.width : zombie.x;
    const lineCount = intensity > 0.5 ? 2 : 1;

    ctx.strokeStyle = color;
    ctx.lineWidth = 1;

    for (let i = 0; i < lineCount; i++) {
        const yOffset = (i === 0 ? -1 : 1) * (5 + Math.random() * 10);
        const lineY = zombie.y + zombie.height / 2 + yOffset;
        const lineLen = 15 + Math.random() * 15;

        ctx.globalAlpha = SPEED_LINE_OPACITY * intensity * (0.6 + Math.random() * 0.4);
        ctx.beginPath();
        ctx.moveTo(startX, lineY);
        ctx.lineTo(startX + dir * lineLen, lineY);
        ctx.stroke();
    }
    ctx.globalAlpha = 1.0;
}

/** Draw sanity vignette overlay. Intensity scales with getSanityT(). */
function renderVignette() {
    const t = getSanityT();
    if (t < 0.05) return; // no vignette at high sanity

    const w = canvas.width;
    const h = canvas.height;
    const cx = w / 2;
    const cy = h / 2;
    const radius = Math.max(w, h) * 0.7;

    // Radial gradient: transparent center, tier-colored edges
    const tier = getSanityTier(sanity);
    const color = getTierColor(tier);

    const gradient = ctx.createRadialGradient(cx, cy, radius * 0.3, cx, cy, radius);
    gradient.addColorStop(0, 'rgba(0, 0, 0, 0)');
    gradient.addColorStop(1, color);

    ctx.globalAlpha = t * VIGNETTE_MAX_OPACITY;
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, w, h);
    ctx.globalAlpha = 1.0;
}

/** Draw a one-sided vignette flash when drift fires.
 *  Flashes on the side the drift pushed TOWARD so the player
 *  can feel the direction of the interference. Screen-space.
 *  Opacity scales with impulse strength — invisible at high sanity,
 *  dramatic at low sanity. */
function renderDriftVignette() {
    if (drift.flashTimer <= 0 || drift.flashDirection === 0) return;
    if (drift.lastImpulse < 50) return; // too weak for vignette

    const w = canvas.width;
    const h = canvas.height;
    const dir = drift.flashDirection;

    // Opacity scales with impulse strength and flash timer
    const impulseAlpha = Math.min(1, drift.lastImpulse / 300);
    const alpha = (drift.flashTimer / 0.15) * 0.2 * impulseAlpha;

    // Linear gradient from drift-direction edge toward center
    const tier = getSanityTier(sanity);
    const gradient = ctx.createLinearGradient(
        dir > 0 ? w : 0, 0,
        w * 0.5, 0
    );
    gradient.addColorStop(0, getTierColor(tier));
    gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');

    ctx.globalAlpha = alpha;
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, w, h);
    ctx.globalAlpha = 1.0;
}

// ============================================================
// RENDERING
// Canvas-based rendering. Tiles are drawn as colored rectangles,
// the zombie as a green rectangle with "Z" label. Colors shift
// by sanity tier to give visual feedback on current state.
// Architecture note: we clear and redraw every frame rather
// than using dirty rectangles because at 40x15 tiles the fill
// cost is negligible and it avoids artifact bugs.
// ============================================================

const canvas = document.getElementById('game-canvas');
const ctx = canvas.getContext('2d');

// Scale canvas to map size
resizeCanvas();

function render() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // --- Apply screen shake offset ---
    // All rendering is offset by the shake. Save/restore ensures
    // UI elements (drawn outside render()) are not affected.
    ctx.save();
    ctx.translate(camera.shakeX, camera.shakeY);

    // --- Draw tiles ---
    for (let row = 0; row < MAP_ROWS; row++) {
        for (let col = 0; col < MAP_COLS; col++) {
            if (tileMap[row][col]) {
                ctx.fillStyle = '#3a506b';
                ctx.fillRect(col * TILE_SIZE, row * TILE_SIZE, TILE_SIZE, TILE_SIZE);
                // Subtle border for tile edges
                ctx.strokeStyle = '#2c3e50';
                ctx.lineWidth = 1;
                ctx.strokeRect(col * TILE_SIZE, row * TILE_SIZE, TILE_SIZE, TILE_SIZE);
            }
        }
    }

    // --- Draw particles (behind zombie) ---
    renderParticles();

    // --- Speed lines (behind zombie, only at high speed) ---
    renderSpeedLines();

    // --- Draw zombie with squash/stretch ---
    const tier = getSanityTier(sanity);
    let zombieColor = getTierColor(tier);

    // Drift flash: brief white flash when drift impulse fires.
    // Visual feedback so the player knows "that was drift, not me"
    // (Swink: closing the input -> simulation -> feedback loop).
    if (drift.flashTimer > 0) {
        const flashIntensity = drift.flashTimer / 0.15; // 1.0 -> 0.0
        // Blend toward white based on flash intensity
        zombieColor = `rgba(255, 255, 255, ${0.3 + 0.7 * flashIntensity})`;
    }

    // --- Feral input delay: "body resists" visual ---
    // Jitter ±1px and darken 20% so the 30ms delay reads as a
    // game mechanic ("zombie fought me") not input lag.
    let jitterX = 0, jitterY = 0;
    const resisting = drift.inputDelayTimer > 0;
    if (resisting) {
        jitterX = (Math.random() - 0.5) * 2;
        jitterY = (Math.random() - 0.5) * 2;
    }

    // Squash/stretch rendering: scale around the zombie's bottom-center
    // so the feet stay planted on the ground. Without this anchor,
    // squash on landing would push the zombie into the floor.
    const zCenterX = zombie.x + zombie.width / 2;
    const zBottomY = zombie.y + zombie.height;

    ctx.save();
    ctx.translate(zCenterX, zBottomY);
    ctx.scale(zombie.scaleX, zombie.scaleY);
    ctx.translate(-zCenterX, -zBottomY);

    // Apply jitter inside squash/stretch transform
    if (jitterX !== 0 || jitterY !== 0) {
        ctx.translate(jitterX, jitterY);
    }

    ctx.fillStyle = zombieColor;
    ctx.fillRect(zombie.x, zombie.y, zombie.width, zombie.height);

    // Darken overlay when body is resisting direction change
    if (resisting) {
        ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
        ctx.fillRect(zombie.x, zombie.y, zombie.width, zombie.height);
    }

    // Draw the tier color as an outline during flash so the zombie
    // doesn't become invisible — the flash overlays, not replaces
    if (drift.flashTimer > 0) {
        ctx.strokeStyle = getTierColor(tier);
        ctx.lineWidth = 2;
        ctx.strokeRect(zombie.x, zombie.y, zombie.width, zombie.height);
    }

    // "Z" label
    ctx.fillStyle = '#000';
    ctx.font = 'bold 18px Consolas, monospace';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText('Z', zombie.x + zombie.width / 2, zombie.y + zombie.height / 2);

    ctx.restore(); // end squash/stretch transform

    // --- Draw direction indicator (small arrow showing velocity) ---
    if (Math.abs(zombie.vx) > 10) {
        const arrowX = zombie.vx > 0
            ? zombie.x + zombie.width + 4
            : zombie.x - 8;
        const arrowDir = zombie.vx > 0 ? '>' : '<';
        ctx.fillStyle = zombieColor;
        ctx.font = '12px Consolas, monospace';
        ctx.textAlign = 'center';
        ctx.fillText(arrowDir, arrowX, zombie.y + zombie.height / 2);
    }

    ctx.restore(); // end screen shake transform

    // --- Sanity vignette (drawn over everything, screen-space) ---
    // Drawn AFTER restoring shake transform so the vignette stays
    // fixed on screen — the world shakes, the vignette doesn't.
    renderVignette();

    // --- Feral drift directional vignette (screen-space) ---
    // Brief flash on the side the drift pushed toward.
    renderDriftVignette();
}

// ============================================================
// UI — DEBUG PANEL
// Real-time movement diagnostics. Updates every frame. This is
// the designer's primary tool for understanding why movement
// feels wrong (Koster: making the system's patterns visible).
// ============================================================

const debugPanel = document.getElementById('debug-panel');

function updateDebugPanel() {
    const tier = getSanityTier(sanity);
    const lines = [
        `Sanity: ${sanity.toFixed(1)} (${tier})`,
        `Velocity: (${zombie.vx.toFixed(0)}, ${zombie.vy.toFixed(0)})`,
        `Speed: ${Math.abs(zombie.vx).toFixed(0)} / ${getMaxSpeed().toFixed(0)}`,
        `Grounded: ${zombie.grounded}`,
        `Coyote: ${zombie.coyoteTimer.toFixed(2)}`,
        `Jump Buffer: ${zombie.jumpBufferTimer.toFixed(2)}`,
        `Air Control: ${getAirControl().toFixed(2)}`,
        `Drift Impulse: ${getDriftImpulse().toFixed(0)}`,
        `Drift Interval: ${getDriftInterval().toFixed(1)}s`,
        `Drift Timer: ${drift.timer.toFixed(2)}`,
        `Input Delay Max: ${(getInputDelay() * 1000).toFixed(0)}ms`,
        `Jump Vel: ${getJumpVelocity().toFixed(0)}`,
        `Decel: ${getDeceleration().toFixed(0)}`,
    ];

    if (drift.inputDelayTimer > 0) {
        lines.push(`Input Delay: ${drift.inputDelayTimer.toFixed(3)}`);
    }

    debugPanel.textContent = lines.join('\n');
}

// ============================================================
// UI — SANITY SLIDER
// The star of the UI — lets the designer instantly feel the
// difference between tiers without code changes. Must be
// responsive and real-time (Schell Lens #18: Flow — UI must
// not interrupt the testing flow).
// ============================================================

const sanitySlider = document.getElementById('sanity-slider');
const sanityLabel = document.getElementById('sanity-label');
const goneOverlay = document.getElementById('gone-overlay');

sanitySlider.addEventListener('input', () => {
    sanity = parseFloat(sanitySlider.value);
    updateSanityUI();
});

function updateSanityUI() {
    const tier = getSanityTier(sanity);
    const color = getTierColor(tier);
    sanityLabel.textContent = `Sanity: ${sanity.toFixed(1)} (${tier})`;
    sanityLabel.style.color = color;

    // Gone overlay
    if (tier === 'Gone') {
        goneOverlay.classList.add('active');
    } else {
        goneOverlay.classList.remove('active');
    }
}

// ============================================================
// UI — TUNING PANEL
// Collapsible panel with sliders for all movement constants.
// Changes apply instantly — rapid iteration without editing
// code. Each slider writes directly to the corresponding let
// variable in the constants section.
// ============================================================

const tuningToggle = document.getElementById('tuning-toggle');
const tuningPanel = document.getElementById('tuning-panel');

tuningToggle.addEventListener('click', () => {
    tuningPanel.classList.toggle('open');
    tuningToggle.textContent = tuningPanel.classList.contains('open') ? 'Tuning ▼' : 'Tuning';
});

// Tuning parameter definitions: [label, variableName, min, max, step]
const tuningParams = [
    { section: 'Base Movement' },
    { label: 'Max Speed', key: 'BASE_MAX_SPEED', min: 100, max: 600, step: 10 },
    { label: 'Acceleration', key: 'BASE_ACCELERATION', min: 500, max: 3000, step: 50 },
    { label: 'Deceleration', key: 'BASE_DECELERATION', min: 500, max: 3000, step: 50 },
    { label: 'Air Control', key: 'BASE_AIR_CONTROL', min: 0, max: 1, step: 0.05 },

    { section: 'Jump' },
    { label: 'Jump Velocity', key: 'JUMP_VELOCITY', min: -800, max: -300, step: 10 },
    { label: 'Gravity', key: 'GRAVITY', min: 800, max: 2000, step: 50 },
    { label: 'Coyote Time', key: 'COYOTE_TIME', min: 0, max: 0.3, step: 0.01 },
    { label: 'Jump Buffer', key: 'JUMP_BUFFER_TIME', min: 0, max: 0.3, step: 0.01 },

    { section: 'Sanity Sliding Scales' },
    { label: 'Speed ×', key: 'FERAL_SPEED_MULT', min: 1.0, max: 3.0, step: 0.1 },
    { label: 'Accel ×', key: 'FERAL_ACCEL_MULT', min: 1.0, max: 3.0, step: 0.1 },
    { label: 'Air Ctrl ×', key: 'FERAL_AIR_CONTROL_MULT', min: 0.1, max: 1.0, step: 0.05 },
    { label: 'Jump ×', key: 'FERAL_JUMP_MULT', min: 1.0, max: 2.0, step: 0.05 },
    { label: 'Decel ×', key: 'FERAL_DECEL_MULT', min: 0.1, max: 1.0, step: 0.05 },
    { label: 'Gravity ×', key: 'FERAL_GRAVITY_MULT', min: 1.0, max: 2.0, step: 0.05 },

    { section: 'Drift (Smooth)' },
    { label: 'Base Impulse', key: 'DRIFT_BASE_IMPULSE', min: 100, max: 800, step: 25 },
    { label: 'Impulse Exp', key: 'DRIFT_IMPULSE_EXPONENT', min: 1.0, max: 3.0, step: 0.25 },
    { label: 'Min Interval', key: 'DRIFT_MIN_INTERVAL', min: 0.3, max: 2.0, step: 0.1 },
    { label: 'Max Interval', key: 'DRIFT_MAX_INTERVAL', min: 2.0, max: 10.0, step: 0.5 },
    { label: 'Airborne ×', key: 'DRIFT_AIRBORNE_MULT', min: 1.0, max: 4.0, step: 0.25 },
    { label: 'Nudge Scale', key: 'DRIFT_NUDGE_SCALE', min: 0.02, max: 0.2, step: 0.01 },
    { label: 'Vel Residue', key: 'DRIFT_VELOCITY_RESIDUE', min: 0.0, max: 0.6, step: 0.05 },
    { label: 'Max Delay', key: 'FERAL_INPUT_DELAY', min: 0, max: 0.1, step: 0.005 },
    { label: 'Delay Onset', key: 'INPUT_DELAY_ONSET_T', min: 0.2, max: 0.8, step: 0.05 },

    { section: 'Juice' },
    { label: 'Scale Lerp', key: 'SCALE_LERP_RATE', min: 4, max: 25, step: 1 },
    { label: 'Jump Sqsh X', key: 'JUMP_SQUASH_X', min: 1.0, max: 1.4, step: 0.05 },
    { label: 'Jump Sqsh Y', key: 'JUMP_SQUASH_Y', min: 0.6, max: 1.0, step: 0.05 },
    { label: 'Land Str Y', key: 'LAND_STRETCH_MAX_Y', min: 0.05, max: 0.4, step: 0.05 },
    { label: 'Land Shake', key: 'LANDING_SHAKE_INTENSITY', min: 1, max: 8, step: 1 },
    { label: 'Vignette', key: 'VIGNETTE_MAX_OPACITY', min: 0, max: 0.5, step: 0.05 },
    { label: 'Spd Thresh', key: 'SPEED_LINE_THRESHOLD', min: 0.5, max: 1.0, step: 0.05 },
    { label: 'Spd Opacity', key: 'SPEED_LINE_OPACITY', min: 0, max: 0.6, step: 0.05 },
];

// We store references to the global variables via eval for live read/write.
// Architecture note: using eval here is acceptable because the keys are
// hardcoded string literals defined above — no user input reaches eval.
function buildTuningPanel() {
    let html = '';

    for (const param of tuningParams) {
        if (param.section) {
            html += `<div class="section-label">${param.section}</div>`;
            continue;
        }

        const currentVal = eval(param.key);
        const id = `tune-${param.key}`;
        html += `
            <label>
                <span>${param.label}</span>
                <input type="range" id="${id}" min="${param.min}" max="${param.max}"
                       step="${param.step}" value="${currentVal}"
                       data-key="${param.key}">
                <span id="${id}-val" style="min-width:45px;text-align:right">${currentVal}</span>
            </label>
        `;
    }

    // Level Generator section
    html += `<div class="section-label">Level Generator</div>`;
    html += `
        <label><span>Width</span>
            <input type="range" id="gen-width" min="20" max="60" step="1" value="${MAP_COLS}">
            <span id="gen-width-val" style="min-width:45px;text-align:right">${MAP_COLS}</span>
        </label>
        <label><span>Height</span>
            <input type="range" id="gen-height" min="15" max="35" step="1" value="${MAP_ROWS}">
            <span id="gen-height-val" style="min-width:45px;text-align:right">${MAP_ROWS}</span>
        </label>
        <label><span>Density</span>
            <input type="range" id="gen-density" min="10" max="90" step="5" value="50">
            <span id="gen-density-val" style="min-width:45px;text-align:right">0.5</span>
        </label>
        <label><span>Min Sanity</span>
            <input type="range" id="gen-sanity" min="1" max="12" step="1" value="7">
            <span id="gen-sanity-val" style="min-width:45px;text-align:right">7</span>
        </label>
        <label><span>Seed</span>
            <input type="number" id="gen-seed" value="42" class="gen-seed-input">
        </label>
        <label style="cursor:pointer"><span>Pacing</span>
            <input type="checkbox" id="gen-pacing" ${PACING_ENABLED ? 'checked' : ''} style="width:auto;margin-left:8px">
        </label>
        <label><span>Diff Scale</span>
            <input type="range" id="gen-diff-scale" min="0.5" max="1.5" step="0.1" value="${PACING_DIFFICULTY_SCALE}">
            <span id="gen-diff-scale-val" style="min-width:45px;text-align:right">${PACING_DIFFICULTY_SCALE.toFixed(1)}</span>
        </label>
        <div class="gen-button-row">
            <button onclick="doGenerate()">Generate</button>
            <button onclick="doRandomGenerate()">Random</button>
            <button onclick="loadPresetGauntlet()">Gauntlet</button>
        </div>
    `;

    tuningPanel.innerHTML = html;

    // Attach listeners for tuning sliders
    for (const param of tuningParams) {
        if (param.section) continue;
        const id = `tune-${param.key}`;
        const slider = document.getElementById(id);
        const valSpan = document.getElementById(`${id}-val`);

        slider.addEventListener('input', () => {
            const val = parseFloat(slider.value);
            // Write to the global variable
            eval(`${param.key} = ${val}`);
            valSpan.textContent = param.step < 1 ? val.toFixed(2) : val;
        });
    }

    // Attach listeners for generator sliders
    document.getElementById('gen-width').addEventListener('input', function() {
        document.getElementById('gen-width-val').textContent = this.value;
    });
    document.getElementById('gen-height').addEventListener('input', function() {
        document.getElementById('gen-height-val').textContent = this.value;
    });
    document.getElementById('gen-density').addEventListener('input', function() {
        document.getElementById('gen-density-val').textContent = (this.value / 100).toFixed(1);
    });
    document.getElementById('gen-sanity').addEventListener('input', function() {
        document.getElementById('gen-sanity-val').textContent = this.value;
    });
    document.getElementById('gen-pacing').addEventListener('change', function() {
        PACING_ENABLED = this.checked;
    });
    document.getElementById('gen-diff-scale').addEventListener('input', function() {
        PACING_DIFFICULTY_SCALE = parseFloat(this.value);
        document.getElementById('gen-diff-scale-val').textContent = PACING_DIFFICULTY_SCALE.toFixed(1);
    });
}

// ============================================================
// GAME LOOP
// Fixed-timestep-ish loop using requestAnimationFrame. We cap
// dt to 0.05s (20fps minimum) to prevent the "spiral of death"
// where large dt causes physics to explode, which causes even
// larger dt next frame.
// ============================================================

let lastTime = 0;

function gameLoop(currentTime) {
    const deltaTime = (currentTime - lastTime) / 1000;
    lastTime = currentTime;

    // Cap dt to prevent physics explosion on tab-switch or lag spike
    const dt = Math.min(deltaTime, 0.05);

    // Skip the first frame (deltaTime would be huge)
    if (deltaTime > 0 && deltaTime < 1) {
        processInput();
        updatePhysics(dt);
        updateDrift(dt);
        updateJuice(dt);
        render();
        updateDebugPanel();
        updateSanityUI();
    }

    requestAnimationFrame(gameLoop);
}

// ============================================================
// INITIALIZATION
// Set up everything and start the loop. Canvas is already sized
// in the rendering section. Tuning panel is built dynamically.
// ============================================================

function init() {
    buildTuningPanel();
    updateSanityUI();
    findAndSetSpawn();
    requestAnimationFrame(gameLoop);
}

init();
</script>
</body>
</html>
