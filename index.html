<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Zombie Movement Toy</title>
<style>
/* ============================================================
   STYLES
   Minimal styling — canvas-centric layout with UI overlay.
   ============================================================ */
* { margin: 0; padding: 0; box-sizing: border-box; }

body {
    background: #1a1a2e;
    display: flex;
    flex-direction: column;
    align-items: center;
    font-family: 'Segoe UI', Arial, sans-serif;
    color: #e0e0e0;
    overflow-x: hidden;
}

#game-container {
    position: relative;
    margin-top: 10px;
}

canvas {
    display: block;
    border: 2px solid #444;
    background: #16213e;
}

/* --- Sanity Slider (top bar) --- */
#sanity-bar {
    width: 100%;
    max-width: 1284px; /* updated dynamically by resizeCanvas() */
    padding: 8px 16px;
    background: #0f3460;
    display: flex;
    align-items: center;
    gap: 12px;
    border-radius: 0 0 6px 6px;
}

#sanity-bar label {
    font-weight: bold;
    font-size: 14px;
    white-space: nowrap;
    min-width: 180px;
}

#sanity-slider {
    flex: 1;
    height: 6px;
    cursor: pointer;
    accent-color: #53d769;
}

/* --- Debug Panel (overlaid on canvas) --- */
#debug-panel {
    position: absolute;
    top: 8px;
    right: 8px;
    background: rgba(0, 0, 0, 0.75);
    padding: 8px 12px;
    font-family: 'Consolas', 'Courier New', monospace;
    font-size: 12px;
    line-height: 1.5;
    color: #aaffaa;
    border-radius: 4px;
    pointer-events: none;
    white-space: pre;
    min-width: 200px;
}

/* --- Tuning Panel (collapsible side panel) --- */
#tuning-toggle {
    position: absolute;
    top: 8px;
    left: 8px;
    background: rgba(0, 0, 0, 0.75);
    color: #e0e0e0;
    border: 1px solid #555;
    padding: 4px 10px;
    font-size: 12px;
    cursor: pointer;
    border-radius: 4px;
    z-index: 10;
}
#tuning-toggle:hover { background: rgba(50, 50, 80, 0.9); }

#tuning-panel {
    position: absolute;
    top: 36px;
    left: 8px;
    background: rgba(0, 0, 0, 0.85);
    padding: 10px 14px;
    font-family: 'Consolas', 'Courier New', monospace;
    font-size: 11px;
    line-height: 1.8;
    color: #cccccc;
    border-radius: 4px;
    max-height: 750px;
    overflow-y: auto;
    width: 280px;
    display: none;
    z-index: 5;
}

#tuning-panel.open { display: block; }

#tuning-panel label {
    display: flex;
    justify-content: space-between;
    align-items: center;
    gap: 6px;
}

#tuning-panel input[type="range"] {
    width: 100px;
    height: 4px;
    cursor: pointer;
    accent-color: #53d769;
}

#tuning-panel .section-label {
    color: #ffcc00;
    font-weight: bold;
    margin-top: 6px;
    border-bottom: 1px solid #555;
    padding-bottom: 2px;
}

/* --- Gone overlay (sanity game over) --- */
#gone-overlay {
    position: absolute;
    top: 0; left: 0; right: 0; bottom: 0;
    display: none;
    justify-content: center;
    align-items: center;
    background: rgba(0, 0, 0, 0.6);
    pointer-events: none;
    z-index: 20;
}
#gone-overlay.active { display: flex; }
#gone-overlay span {
    font-size: 64px;
    font-weight: bold;
    color: #ff3333;
    text-shadow: 0 0 30px #ff0000, 0 0 60px #880000;
    font-family: 'Consolas', monospace;
    letter-spacing: 8px;
}

/* --- HP game over overlay --- */
#game-over-hp-overlay {
    position: absolute;
    top: 0; left: 0; right: 0; bottom: 0;
    display: none;
    justify-content: center;
    align-items: center;
    background: rgba(0, 0, 0, 0.6);
    pointer-events: none;
    z-index: 20;
}
#game-over-hp-overlay.active { display: flex; }
#game-over-hp-overlay span {
    font-size: 64px;
    font-weight: bold;
    color: #ff6b35;
    text-shadow: 0 0 30px #ff6b35, 0 0 60px #884400;
    font-family: 'Consolas', monospace;
    letter-spacing: 8px;
}

/* --- Level complete overlay --- */
#level-complete-overlay {
    position: absolute;
    top: 0; left: 0; right: 0; bottom: 0;
    display: none;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    background: rgba(0, 0, 0, 0.6);
    pointer-events: none;
    z-index: 20;
    gap: 12px;
}
#level-complete-overlay.active { display: flex; }
#level-complete-overlay .title {
    font-size: 56px;
    font-weight: bold;
    color: #53d769;
    text-shadow: 0 0 30px #53d769, 0 0 60px #2a8c3a;
    font-family: 'Consolas', monospace;
    letter-spacing: 6px;
}
#level-complete-overlay .stats {
    font-size: 16px;
    color: #cccccc;
    font-family: 'Consolas', monospace;
    text-align: center;
    line-height: 1.8;
}
#level-complete-overlay .restart {
    font-size: 14px;
    color: #888888;
    font-family: 'Consolas', monospace;
    margin-top: 8px;
}

/* --- Auto drain checkbox --- */
#drain-toggle {
    display: flex;
    align-items: center;
    gap: 4px;
    font-size: 12px;
    white-space: nowrap;
    cursor: pointer;
}
#drain-toggle input { cursor: pointer; }

/* --- Level Generator controls in tuning panel --- */
.gen-seed-input {
    width: 70px;
    background: #0a0a1a;
    border: 1px solid #555;
    color: #e0e0e0;
    padding: 3px 6px;
    font-family: 'Consolas', monospace;
    font-size: 11px;
    border-radius: 3px;
    text-align: right;
}
.gen-button-row {
    display: flex;
    gap: 4px;
    margin: 6px 0;
}
.gen-button-row button {
    flex: 1;
    background: #1a1a3e;
    color: #e0e0e0;
    border: 1px solid #555;
    padding: 4px 8px;
    font-family: 'Consolas', monospace;
    font-size: 11px;
    cursor: pointer;
    border-radius: 3px;
}
.gen-button-row button:hover { background: #2a2a5e; border-color: #53d769; }

/* --- Controls hint --- */
#controls-hint {
    margin-top: 8px;
    font-size: 12px;
    color: #888;
    text-align: center;
}
</style>
</head>
<body>

<div id="sanity-bar">
    <label id="sanity-label">Sanity: 12.0 (Lucid)</label>
    <input type="range" id="sanity-slider" min="0" max="12" step="0.1" value="12">
    <label id="drain-toggle"><input type="checkbox" id="drain-checkbox">Auto Drain</label>
</div>

<div id="game-container">
    <canvas id="game-canvas"></canvas>
    <div id="debug-panel"></div>
    <button id="tuning-toggle">Tuning</button>
    <div id="tuning-panel"></div>
    <div id="gone-overlay"><span>MIND LOST</span></div>
    <div id="game-over-hp-overlay"><span>GAME OVER</span></div>
    <div id="level-complete-overlay">
        <div class="title">LEVEL COMPLETE</div>
        <div class="stats" id="level-complete-stats"></div>
        <div class="restart">Press R to Restart</div>
    </div>
</div>

<div id="controls-hint">
    WASD or Arrow Keys to move &bull; Space to jump &bull; R to restart &bull; Reach EXIT to win &bull; Slider to change sanity tier
</div>

<script>
// ============================================================
// TUNABLE CONSTANTS
// All movement parameters live here. The tuning panel reads and
// writes these at runtime. Values sourced from paper prototype
// MC simulations (zombie-platformer repo docs/GDD.md).
// ============================================================

// --- Base movement (Lucid tier) ---
let BASE_MAX_SPEED = 300;          // px/s — top horizontal speed
let BASE_ACCELERATION = 2800;      // px/s² — how fast we reach max speed (was 2400, bumped for snappier starts)
let BASE_DECELERATION = 3200;      // px/s² — friction when no input
let BASE_AIR_CONTROL = 0.8;        // multiplier on accel while airborne

// --- Jump ---
let JUMP_VELOCITY = -650;          // px/s — initial upward velocity (negative = up, was -600)
let GRAVITY = 1400;                // px/s² — downward pull
let COYOTE_TIME = 0.1;            // seconds — grace period after leaving ground
let JUMP_BUFFER_TIME = 0.1;       // seconds — pre-landing jump input memory

// --- Sanity sliding scales ---
// ALL movement parameters interpolate smoothly across sanity 0-12.
// At sanity 12 the zombie gets base values; at sanity 0 it gets
// the FERAL_*_MULT × base. Linear interpolation between. This
// eliminates dead zones where the slider does nothing (playtest
// finding: tier-stepped values made the progression feel flat).
let FERAL_SPEED_MULT = 1.7;       // max speed at sanity 0 (was 1.5)
let FERAL_ACCEL_MULT = 1.6;       // acceleration at sanity 0
let FERAL_AIR_CONTROL_MULT = 0.5; // air control at sanity 0 (0.8 * 0.5 = 0.4)
let FERAL_JUMP_MULT = 1.6;        // jump strengthens as sanity drops
let FERAL_DECEL_MULT = 0.5;       // friction weakens as sanity drops (more slidey)
let FERAL_GRAVITY_MULT = 1.15;    // gravity increases as sanity drops (tighter arc, less floaty)

// --- Input drift (smooth system) ---
// Drift is the Thrill of Danger mechanic (Garneau/Heeter). Drift
// impulse and interval now interpolate smoothly via getSanityT()
// instead of stepping at tier boundaries. This eliminates the
// "Lucid free zone" (sanity 7-12 was zero cost) and the "Feral
// cliff" (28× cost increase for 5.6% gain at the 4→3.99 boundary).
//
// Impulse uses a squared curve (t²) so drift starts very gently
// at high sanity and accelerates into devastating at low sanity.
// Position nudge + velocity residue replaces pure velocity impulse
// so both same-direction and reverse drift are visible.
let DRIFT_BASE_IMPULSE = 500;            // max impulse (px/s equivalent) at sanity 0
let DRIFT_MIN_INTERVAL = 1.0;            // shortest interval between drifts (at sanity 0, was 0.8)
let DRIFT_MAX_INTERVAL = 5.0;            // longest interval (at sanity 12, effectively never)
let DRIFT_IMPULSE_EXPONENT = 2;          // curve shape: higher = gentler start, sharper end
let DRIFT_AIRBORNE_MULT = 2.0;           // impulse multiplier while not grounded
let DRIFT_NUDGE_SCALE = 0.1;             // px displacement per px/s of impulse (position nudge)
let DRIFT_VELOCITY_RESIDUE = 0.3;        // fraction of impulse applied as velocity change

// --- Input delay (smooth onset) ---
// Direction reversal delay now starts at sanity 6 (INPUT_DELAY_ONSET_T = 0.5)
// and scales to full at sanity 0. Previously only existed at Feral tier.
let FERAL_INPUT_DELAY = 0.03;            // max delay at sanity 0 (seconds)
let INPUT_DELAY_ONSET_T = 0.5;           // getSanityT() threshold where delay begins (sanity 6)

// --- Juice / feedback ---
// Feedback parameters for squash/stretch, particles, shake, and
// vignette. These close Swink's simulation → feedback loop so
// player actions feel alive instead of just moving a rectangle.
let SCALE_LERP_RATE = 12;               // how fast squash/stretch returns to 1.0 (per second)
let JUMP_SQUASH_X = 1.15;               // horizontal stretch on jump launch
let JUMP_SQUASH_Y = 0.80;               // vertical compress on jump launch
let LAND_STRETCH_MAX_Y = 0.20;          // max vertical stretch on landing (added to 1.0)
let LAND_SQUASH_MAX_X = 0.12;           // max horizontal compress on landing (subtracted from 1.0)
let LAND_VY_SCALE = 3000;               // vy divisor for landing intensity (higher = less intense)
let LANDING_SHAKE_MIN_VY = 400;         // minimum vy to trigger landing screen shake
let LANDING_SHAKE_INTENSITY = 4;        // max shake pixels for heaviest landing
let REVERSAL_SQUASH_X = 0.90;           // horizontal compress on high-speed direction reversal
let REVERSAL_MIN_SPEED = 200;           // minimum |vx| before reversal to trigger dust/squash
let PARTICLE_GRAVITY = 100;             // px/s² downward on dust particles
let VIGNETTE_MAX_OPACITY = 0.25;        // max vignette opacity at sanity 0
let SPEED_LINE_THRESHOLD = 0.8;         // fraction of max speed to start showing lines
let SPEED_LINE_OPACITY = 0.3;           // max opacity of speed lines
// --- Sanity drain ---
let SANITY_DRAIN_RATE = 0.15;           // sanity lost per second (continuous)

// --- Health system ---
let ZOMBIE_MAX_HP = 5;                  // max hit points
let ZOMBIE_START_HP = 5;               // HP at level start
let INVINCIBILITY_DURATION = 0.75;     // seconds of iframes after taking damage

// --- Civilian system ---
let CIVILIAN_FLEE_SPEED = 60;          // px/s — flee movement speed
let CIVILIAN_FLEE_RANGE = 96;          // px — distance at which civilian begins fleeing
let CIVILIAN_SEEK_RANGE = 128;         // px — distance within which civilian drifts toward guard (placeholder)
let CIVILIAN_WANDER_SPEED = 30;        // px/s — idle movement speed

// --- Eat + death scream ---
let SANITY_PER_EAT = 4;               // sanity restored per civilian eaten
let SCREAM_ALERT_RANGE = 128;          // px — death scream alert radius
let SCREAM_ALERT_DURATION = 3.0;       // seconds — guard investigation time

// --- Guard system ---
let GUARD_SPEED = 120;                // px/s — patrol movement speed
let GUARD_CHASE_SPEED = 200;          // px/s — chase movement speed
let GUARD_DAMAGE = 1;                 // HP per hit
let GUARD_DETECTION_RANGE = 160;      // px — aggro range
let GUARD_PATROL_RANGE = 128;         // px — default patrol (no civilian)
let GUARD_WATCH_RANGE = 64;           // px — patrol radius around guarded civilian
let GUARD_LEASH_DISTANCE = 160;       // px — max chase distance from guarded civilian
let POUNCE_SANITY_THRESHOLD = 4;       // sanity below which pounce is active (Feral boundary)

// ============================================================
// TILE MAP
// "Sanity Gauntlet" — 40 x 25 tiles. Designed so platforms are
// IMPOSSIBLE at full Lucid (sanity 12) and require progressively
// lower sanity to reach. Forces the player to trade control for
// ability, testing the core design tension.
//
// Jump peaks by sanity (FERAL_JUMP_MULT = 1.6):
//   Sanity 12 (Lucid):    peak ~129px (4 tiles)
//   Sanity  9 (Lucid):    peak ~170px (5.3 tiles)
//   Sanity  5 (Slipping): peak ~234px (7.3 tiles)
//   Sanity  3 (Feral):    peak ~270px (8.4 tiles)
//   Sanity  1 (Feral):    peak ~309px (9.7 tiles)
//
// Tier layout (gap from tier below):
//   Ground  = row 24 (runway, any sanity)
//   Lucid   = row 21 (3 rows up — easy at sanity 12)
//   Slip    = row 16 (5 rows up — needs sanity ≤ 9)
//   Feral   = row  8 (8 rows up — needs sanity ≤ 3)
//   Summit  = row  2 (6 rows up — already Feral, easy)
//
// Row 21 also has a 10-tile horizontal gap: Lucid max range
// is ~8 tiles, so the gap requires Feral speed to cross.
// ============================================================

const TILE_SIZE = 32;
let MAP_COLS = 50;
let MAP_ROWS = 18;

const PRESET_GAUNTLET = [
    '........................................', // row 0
    '........................................', // row 1
    '......====......====....................', // row 2  Summit
    '........................................', // row 3
    '........................................', // row 4
    '........................................', // row 5
    '........................................', // row 6
    '........................................', // row 7
    '..====..............====..........====..', // row 8  Feral zone
    '........................................', // row 9
    '........................................', // row 10
    '........................................', // row 11
    '........................................', // row 12
    '........................................', // row 13
    '........................................', // row 14
    '........................................', // row 15
    '====..........====..........====........', // row 16 Slipping zone
    '........................................', // row 17
    '........................................', // row 18
    '........................................', // row 19
    '........................................', // row 20
    '....====..====..====..........====..====', // row 21 Lucid zone (10-tile gap)
    '........................................', // row 22
    '........................................', // row 23
    '========================================', // row 24 Ground (runway)
];

// ============================================================
// LEVEL 1: "First Run"
// Purpose-built level demonstrating the complete core loop.
// Ground path always completable at any sanity. Upper platforms
// are optional rewards gated behind lower sanity thresholds.
// 50 × 18 tiles (1600 × 576 canvas)
// ============================================================
const LEVEL_1 = {
    name: 'Level 1',
    cols: 50,
    rows: 18,
    map: [
        '==================================================', // row 0  ceiling
        '..................................................', // row 1
        '..................................................', // row 2
        '..................................................', // row 3
        '..................................................', // row 4
        '..................................................', // row 5
        '..................................................', // row 6
        '..................................................', // row 7
        '..................................................', // row 8
        '.........................===.=====................', // row 9  HIGH platform
        '..................................................', // row 10
        '..................................................', // row 11
        '..................................................', // row 12
        '...............=====.===..........................', // row 13 stepping stones
        '....===..................................===......', // row 14 low shelves
        '..................................................', // row 15
        '..................................................', // row 16
        '============...=================...===...=========', // row 17 ground with 3 gaps
    ],
    civilians: [
        { col: 7,  row: 17 },  // Unguarded, free eat (Section A)
        { col: 20, row: 17 },  // Guarded by Guard 1 (Section B)
        { col: 31, row: 9  },  // Unguarded, high platform (Section C)
        { col: 36, row: 17 },  // Guarded by Guard 2 (Section C)
        { col: 44, row: 17 },  // Guarded by Guard 3 (Section D)
    ],
    guards: [
        { col: 21, row: 17 },  // Guards Civilian 2
        { col: 35, row: 17 },  // Guards Civilian 4
        { col: 45, row: 17 },  // Guards Civilian 5
    ],
};

// ============================================================
// ROOM-GRID LEVEL GENERATOR (Spelunky-style)
// Hand-designed room templates arranged procedurally on a grid.
// Critical path from left to right with vertical diversions.
// ============================================================

const ROOM_W = 12;    // tiles per room width
const ROOM_H = 12;    // tiles per room height
const GRID_COLS = 10; // rooms across
const GRID_ROWS = 4;  // rooms down

const ROOM_TEMPLATES = [
    // 12x12 rooms. Connection zones (enforced post-stamp):
    //   Left:   cols 0-2, rows 6-10 empty, row 11 solid (3 wide × 5 tall)
    //   Right:  cols 9-11, rows 6-10 empty, row 11 solid (3 wide × 5 tall)
    //   Top:    rows 0-1, cols 3-8 empty + row 2 ledges at cols 3 & 8
    //   Bottom: rows 10-11, cols 3-8 empty

    // --- L+R rooms (horizontal traversal) ---
    {
        id: 'flat_ground',
        tiles: [
            '============',
            '............',
            '............',
            '............',
            '......====..',
            '............',
            '............',
            '..====......',
            '............',
            '............',
            '............',
            '============',
        ],
        connections: { left: true, right: true, top: false, bottom: false },
        difficulty: 1,
    },
    {
        id: 'gap_jump',
        tiles: [
            '============',
            '............',
            '............',
            '............',
            '............',
            '........===.',
            '............',
            '............',
            '....===.....',
            '............',
            '............',
            '======.=====',
        ],
        connections: { left: true, right: true, top: false, bottom: false },
        difficulty: 1,
    },
    {
        id: 'platforms_up',
        tiles: [
            '============',
            '............',
            '..======....',
            '............',
            '............',
            '........====',
            '............',
            '....====....',
            '............',
            '............',
            '............',
            '==..========',
        ],
        connections: { left: true, right: true, top: false, bottom: false },
        difficulty: 2,
    },
    {
        id: 'corridor_low',
        tiles: [
            '============',
            '............',
            '............',
            '............',
            '............',
            '............',
            '=====..=====',
            '............',
            '............',
            '............',
            '............',
            '============',
        ],
        connections: { left: true, right: true, top: false, bottom: false },
        difficulty: 1,
    },
    {
        id: 'zigzag',
        tiles: [
            '============',
            '............',
            '............',
            '..........==',
            '............',
            '......====..',
            '............',
            '..====......',
            '............',
            '==..........',
            '............',
            '============',
        ],
        connections: { left: true, right: true, top: false, bottom: false },
        difficulty: 2,
    },
    // --- L+T rooms (enter left, climb to top exit) ---
    {
        id: 'climb_exit_top',
        tiles: [
            '===......===',
            '....====....',
            '............',
            '..====......',
            '............',
            '............',
            '........====',
            '............',
            '....====....',
            '............',
            '............',
            '============',
        ],
        connections: { left: true, right: false, top: true, bottom: false },
        difficulty: 2,
    },
    // --- L+B rooms (enter left, drop through floor) ---
    {
        id: 'drop_exit_bottom',
        tiles: [
            '============',
            '............',
            '............',
            '............',
            '....====....',
            '............',
            '............',
            '............',
            '............',
            '............',
            '............',
            '===......===',
        ],
        connections: { left: true, right: false, top: false, bottom: true },
        difficulty: 1,
    },
    // --- B+R rooms (land from above, exit right) ---
    {
        id: 'enter_from_above',
        tiles: [
            '============',
            '............',
            '............',
            '......====..',
            '............',
            '............',
            '..====......',
            '............',
            '............',
            '........====',
            '............',
            '===......===',
        ],
        connections: { left: false, right: true, top: false, bottom: true },
        difficulty: 2,
    },
    // --- T+R rooms (climb up from below, exit right) ---
    {
        id: 'enter_from_below',
        tiles: [
            '===......===',
            '....====....',
            '............',
            '..====......',
            '............',
            '............',
            '........====',
            '............',
            '............',
            '............',
            '............',
            '============',
        ],
        connections: { left: false, right: true, top: true, bottom: false },
        difficulty: 2,
    },
    // --- T+B rooms (vertical pass-through) ---
    {
        id: 'vertical_shaft',
        tiles: [
            '===......===',
            '....====....',
            '............',
            '..==....==..',
            '............',
            '............',
            '....====....',
            '............',
            '............',
            '..==....==..',
            '............',
            '===......===',
        ],
        connections: { left: false, right: false, top: true, bottom: true },
        difficulty: 1,
    },
    // --- L+R+T rooms ---
    {
        id: 'corridor_top_exit',
        tiles: [
            '===......===',
            '....====....',
            '............',
            '..====......',
            '............',
            '............',
            '........====',
            '............',
            '....====....',
            '............',
            '............',
            '============',
        ],
        connections: { left: true, right: true, top: true, bottom: false },
        difficulty: 2,
    },
    // --- L+R+B rooms ---
    {
        id: 'corridor_bottom_exit',
        tiles: [
            '============',
            '............',
            '............',
            '..====......',
            '............',
            '............',
            '........====',
            '............',
            '............',
            '............',
            '............',
            '===......===',
        ],
        connections: { left: true, right: true, top: false, bottom: true },
        difficulty: 2,
    },
    {
        id: 'wide_bottom_entry',
        tiles: [
            '============',
            '............',
            '............',
            '............',
            '....======..',
            '............',
            '............',
            '............',
            '............',
            '............',
            '............',
            '===......===',
        ],
        connections: { left: true, right: true, top: false, bottom: true },
        difficulty: 1,
    },
    // --- L+R+T rooms (simpler) ---
    {
        id: 'wide_top_entry',
        tiles: [
            '===......===',
            '....====....',
            '............',
            '............',
            '............',
            '............',
            '............',
            '............',
            '..======....',
            '............',
            '............',
            '============',
        ],
        connections: { left: true, right: true, top: true, bottom: false },
        difficulty: 1,
    },
    // --- T+B+R rooms ---
    {
        id: 'shaft_right_exit',
        tiles: [
            '===......===',
            '....====....',
            '............',
            '..====......',
            '............',
            '............',
            '....====....',
            '............',
            '............',
            '........====',
            '............',
            '===......===',
        ],
        connections: { left: false, right: true, top: true, bottom: true },
        difficulty: 2,
    },
    // --- T+B+L rooms ---
    {
        id: 'shaft_left_exit',
        tiles: [
            '===......===',
            '....====....',
            '............',
            '........====',
            '............',
            '............',
            '....====....',
            '............',
            '............',
            '..====......',
            '............',
            '===......===',
        ],
        connections: { left: true, right: false, top: true, bottom: true },
        difficulty: 2,
    },
    // --- All connections (L+R+T+B) ---
    {
        id: 'crossroads',
        tiles: [
            '===......===',
            '....====....',
            '............',
            '..====......',
            '............',
            '............',
            '........====',
            '............',
            '....====....',
            '............',
            '............',
            '===......===',
        ],
        connections: { left: true, right: true, top: true, bottom: true },
        difficulty: 2,
    },
    // --- Single-connection rooms (dead-end corridors for non-path rooms) ---
    {
        id: 'end_left',
        tiles: [
            '============',
            '............',
            '............',
            '............',
            '......====..',
            '............',
            '............',
            '..====......',
            '............',
            '............',
            '............',
            '============',
        ],
        connections: { left: true, right: false, top: false, bottom: false },
        difficulty: 1,
    },
    {
        id: 'end_right',
        tiles: [
            '============',
            '............',
            '............',
            '............',
            '..====......',
            '............',
            '............',
            '......====..',
            '............',
            '............',
            '............',
            '============',
        ],
        connections: { left: false, right: true, top: false, bottom: false },
        difficulty: 1,
    },
    {
        id: 'end_top',
        tiles: [
            '===......===',
            '....====....',
            '............',
            '..====......',
            '............',
            '............',
            '........====',
            '............',
            '............',
            '............',
            '............',
            '============',
        ],
        connections: { left: false, right: false, top: true, bottom: false },
        difficulty: 1,
    },
    {
        id: 'end_bottom',
        tiles: [
            '============',
            '............',
            '............',
            '............',
            '........====',
            '............',
            '............',
            '..====......',
            '............',
            '............',
            '............',
            '===......===',
        ],
        connections: { left: false, right: false, top: false, bottom: true },
        difficulty: 1,
    },
    // --- Dead end (solid wall filler) ---
    {
        id: 'dead_end',
        tiles: [
            '============',
            '============',
            '============',
            '============',
            '============',
            '============',
            '============',
            '============',
            '============',
            '============',
            '============',
            '============',
        ],
        connections: { left: false, right: false, top: false, bottom: false },
        difficulty: 0,
    },
];

// Track which level is currently loaded for resetGameState()
let currentLevel = 'level1';

let MAP_DATA = [...LEVEL_1.map];

// Parse map into a 2D boolean grid: true = solid tile
let tileMap = MAP_DATA.map(row =>
    Array.from(row).map(ch => ch === '=')
);

// ============================================================
// LEVEL GENERATOR
// Procedural physics-aware platform generation. Calculates the
// jump envelope from the actual physics constants, builds
// layers bottom-up, adds stepping stones, then validates
// reachability via BFS.
// ============================================================

/** Seeded PRNG (splitmix32) — returns a function producing 0..1 floats */
function splitmix32(seed) {
    let s = seed | 0;
    return function() {
        s |= 0;
        s = s + 0x9e3779b9 | 0;
        let t = s ^ (s >>> 16);
        t = Math.imul(t, 0x21f0aaad);
        t = t ^ (t >>> 15);
        t = Math.imul(t, 0x735a2d97);
        t = t ^ (t >>> 15);
        return (t >>> 0) / 4294967296;
    };
}

/** Calculate jump envelope from real physics constants at a given sanity */
function calcJumpEnvelope(san) {
    // Smooth interpolation: t=0 at sanity 12, t=1 at sanity 0
    const t = Math.max(0, Math.min(1, (12 - san) / 12));
    const jumpVel = Math.abs(JUMP_VELOCITY * (1 + t * (FERAL_JUMP_MULT - 1)));

    // Gravity also scales with sanity
    const grav = GRAVITY * (1 + t * (FERAL_GRAVITY_MULT - 1));

    // Peak height from kinematics: h = v² / (2g)
    const peakPx = (jumpVel * jumpVel) / (2 * grav);
    const maxUpTiles = Math.floor(peakPx / TILE_SIZE);

    // Horizontal range at peak: time_to_peak = v/g, distance = speed * time
    const maxSpeed = BASE_MAX_SPEED * (1 + t * (FERAL_SPEED_MULT - 1));
    const timeToPeak = jumpVel / grav;
    const horizPx = maxSpeed * timeToPeak;
    const maxAcrossTiles = Math.floor(horizPx / TILE_SIZE);

    return { maxUpTiles, maxAcrossTiles };
}

/** Quick pairwise reachability check (elliptical envelope) */
function canReachPlatform(ax, ay, bx, by, maxUp, maxAcross) {
    const dx = Math.abs(bx - ax);
    const dy = ay - by; // positive = jumping up
    if (dy <= 0) return dx <= maxAcross + 1;
    return (dx / (maxAcross + 1)) ** 2 + (dy / (maxUp + 0.5)) ** 2 <= 1;
}

/** BFS reachability validation — removes platforms unreachable from ground */
function validateReachability(grid, w, h, maxUp, maxAcross) {
    const groundY = h - 1;

    function solid(x, y) {
        if (x < 0 || x >= w || y < 0 || y >= h) return true;
        return grid[y][x];
    }
    function canStand(x, y) {
        if (solid(x, y)) return false;
        return y === h - 1 || solid(x, y + 1);
    }
    function gravity(x, y) {
        while (y < h - 1 && !solid(x, y + 1)) y++;
        if (solid(x, y)) return null;
        return { x, y };
    }

    const reachable = new Set();
    const visited = new Set();
    const queue = [];

    // Seed from ground-level standing positions
    for (let x = 0; x < w; x++) {
        for (let y = groundY - 2; y <= groundY; y++) {
            if (y >= 0 && canStand(x, y)) {
                const key = `${x},${y}`;
                if (!visited.has(key)) {
                    visited.add(key);
                    queue.push({ x, y });
                }
            }
        }
    }

    while (queue.length > 0) {
        const cur = queue.shift();
        reachable.add(`${cur.x},${cur.y}`);
        const moves = [];

        // Horizontal moves
        for (const dx of [-1, 1]) {
            const nx = cur.x + dx;
            if (!solid(nx, cur.y)) {
                const landed = gravity(nx, cur.y);
                if (landed) moves.push(landed);
            }
        }

        // Jumps
        if (canStand(cur.x, cur.y)) {
            for (let jumpH = 1; jumpH <= maxUp; jumpH++) {
                const upY = cur.y - jumpH;
                let clear = true;
                for (let cy = 1; cy <= jumpH; cy++) {
                    if (solid(cur.x, cur.y - cy)) { clear = false; break; }
                }
                if (!clear) break;

                const landed = gravity(cur.x, upY);
                if (landed && (landed.x !== cur.x || landed.y !== cur.y)) moves.push(landed);

                for (const ddx of [-1, 1]) {
                    for (let reach = 1; reach <= maxAcross; reach++) {
                        const ax = cur.x + ddx * reach;
                        let hClear = true;
                        for (let r = 1; r <= reach; r++) {
                            if (solid(cur.x + ddx * r, upY)) { hClear = false; break; }
                        }
                        if (!hClear) break;
                        const landed2 = gravity(ax, upY);
                        if (landed2) moves.push(landed2);
                    }
                }
            }
        }

        for (const m of moves) {
            const key = `${m.x},${m.y}`;
            if (!visited.has(key)) {
                visited.add(key);
                queue.push(m);
            }
        }
    }

    // Remove platform tiles where the standing surface is unreachable
    for (let y = 1; y < h - 1; y++) {
        for (let x = 1; x < w - 1; x++) {
            if (!grid[y][x]) continue;
            if (y === 0) continue;
            if (!canStand(x, y - 1)) continue;
            if (!reachable.has(`${x},${y - 1}`)) {
                grid[y][x] = false;
            }
        }
    }
}

// ============================================================
// ROOM-GRID FUNCTIONS
// ============================================================

/** Generate critical path through room grid (Spelunky-style, rotated for horizontal).
 *  Start at (0, middle row), walk RIGHT with vertical diversions, end at last col. */
function generateCriticalPath(cols, rows, rng) {
    const path = [];
    const connections = new Map(); // "col,row" → {left, right, top, bottom}

    let col = 0, row = Math.floor(rows / 2); // start at mid-height
    path.push({ col, row });
    connections.set(`${col},${row}`, { left: false, right: false, top: false, bottom: false });

    let consecutiveRight = 0; // force vertical diversions after 2 straight rights

    while (col < cols - 1) {
        // Pick direction: RIGHT-biased with moderate vertical diversions.
        // After 2 consecutive right moves, force a vertical diversion so the
        // path can't be a straight sprint from start to exit.
        const roll = rng();
        let dir;
        const forceVertical = consecutiveRight >= 2;
        if (forceVertical) {
            // Must go up or down
            if (row <= 0) dir = 'down';
            else if (row >= rows - 1) dir = 'up';
            else dir = roll < 0.5 ? 'up' : 'down';
        } else if (roll < 0.28 && row > 0) {
            dir = 'up';
        } else if (roll < 0.56 && row < rows - 1) {
            dir = 'down';
        } else {
            dir = 'right';
        }

        const prevCol = col, prevRow = row;
        const prevKey = `${prevCol},${prevRow}`;

        if (dir === 'up') {
            row--;
            consecutiveRight = 0;
            connections.get(prevKey).top = true;
            const newKey = `${col},${row}`;
            if (!connections.has(newKey)) connections.set(newKey, { left: false, right: false, top: false, bottom: false });
            connections.get(newKey).bottom = true;
        } else if (dir === 'down') {
            row++;
            consecutiveRight = 0;
            connections.get(prevKey).bottom = true;
            const newKey = `${col},${row}`;
            if (!connections.has(newKey)) connections.set(newKey, { left: false, right: false, top: false, bottom: false });
            connections.get(newKey).top = true;
        } else {
            col++;
            consecutiveRight++;
            connections.get(prevKey).right = true;
            const newKey = `${col},${row}`;
            if (!connections.has(newKey)) connections.set(newKey, { left: false, right: false, top: false, bottom: false });
            connections.get(newKey).left = true;
        }

        // Avoid duplicate path entries for same cell (vertical then right through same cell)
        if (path[path.length - 1].col !== col || path[path.length - 1].row !== row) {
            path.push({ col, row });
        }
    }

    return { path, connections };
}

/** Add exploration side-branches off the critical path.
 *  Picks 2-4 path rooms and extends 1-2 room branches perpendicular to the path.
 *  Modifies `connections` in-place and returns the branch cells. */
function addSideBranches(path, connections, cols, rows, rng) {
    const usedSet = new Set(path.map(p => `${p.col},${p.row}`));
    // Also mark any rooms already in connections (shouldn't differ, but safe)
    for (const key of connections.keys()) usedSet.add(key);

    const branchCells = [];

    // Candidates: path rooms excluding first and last (keep start/exit clean)
    const candidates = path.slice(1, -1);
    for (let i = candidates.length - 1; i > 0; i--) {
        const j = Math.floor(rng() * (i + 1));
        [candidates[i], candidates[j]] = [candidates[j], candidates[i]];
    }

    const maxBranches = Math.min(4, Math.max(2, Math.floor(path.length / 3)));
    let branches = 0;

    for (const cell of candidates) {
        if (branches >= maxBranches) break;

        const dirs = [
            { dc: 0, dr: -1, exit: 'top', enter: 'bottom' },
            { dc: 0, dr: 1, exit: 'bottom', enter: 'top' },
            { dc: -1, dr: 0, exit: 'left', enter: 'right' },
            { dc: 1, dr: 0, exit: 'right', enter: 'left' },
        ];
        for (let i = dirs.length - 1; i > 0; i--) {
            const j = Math.floor(rng() * (i + 1));
            [dirs[i], dirs[j]] = [dirs[j], dirs[i]];
        }

        for (const d of dirs) {
            const nc = cell.col + d.dc;
            const nr = cell.row + d.dr;
            if (nc < 0 || nc >= cols || nr < 0 || nr >= rows) continue;
            const nk = `${nc},${nr}`;
            if (usedSet.has(nk)) continue;

            // Open connection on the path room
            const cellKey = `${cell.col},${cell.row}`;
            connections.get(cellKey)[d.exit] = true;

            // Create branch room with entry connection
            usedSet.add(nk);
            const branchConn = { left: false, right: false, top: false, bottom: false };
            branchConn[d.enter] = true;
            connections.set(nk, branchConn);
            branchCells.push({ col: nc, row: nr });

            // 40% chance to extend branch by one more room
            if (rng() < 0.4) {
                const nc2 = nc + d.dc;
                const nr2 = nr + d.dr;
                const nk2 = `${nc2},${nr2}`;
                if (nc2 >= 0 && nc2 < cols && nr2 >= 0 && nr2 < rows && !usedSet.has(nk2)) {
                    connections.get(nk)[d.exit] = true;
                    usedSet.add(nk2);
                    const branch2Conn = { left: false, right: false, top: false, bottom: false };
                    branch2Conn[d.enter] = true;
                    connections.set(nk2, branch2Conn);
                    branchCells.push({ col: nc2, row: nr2 });
                }
            }

            branches++;
            break;
        }
    }

    return branchCells;
}

/** Compute required connections for every cell in the grid.
 *  Connected rooms (path + branches) use their connections from the map.
 *  Non-connected rooms adjacent to connected rooms must match outward-facing
 *  connections. All others get no connections (dead_end). */
function computeAllCellConnections(path, pathConns, cols, rows) {
    const allConns = new Map();
    // connectedSet = all rooms that have explicit connections (path + branches)
    const connectedSet = new Set();
    for (const key of pathConns.keys()) connectedSet.add(key);

    // Start with connected room connections (path + branches)
    for (const [key, conn] of pathConns) {
        allConns.set(key, { ...conn });
    }

    // For each non-connected cell, check if any neighbor is connected with an outward connection
    for (let c = 0; c < cols; c++) {
        for (let r = 0; r < rows; r++) {
            const key = `${c},${r}`;
            if (connectedSet.has(key)) continue;

            const conn = { left: false, right: false, top: false, bottom: false };

            // Check left neighbor (c-1, r): if connected and has right=true, we need left=true
            if (c > 0) {
                const nk = `${c - 1},${r}`;
                if (pathConns.has(nk) && pathConns.get(nk).right) conn.left = true;
            }
            // Check right neighbor
            if (c < cols - 1) {
                const nk = `${c + 1},${r}`;
                if (pathConns.has(nk) && pathConns.get(nk).left) conn.right = true;
            }
            // Check top neighbor
            if (r > 0) {
                const nk = `${c},${r - 1}`;
                if (pathConns.has(nk) && pathConns.get(nk).bottom) conn.top = true;
            }
            // Check bottom neighbor
            if (r < rows - 1) {
                const nk = `${c},${r + 1}`;
                if (pathConns.has(nk) && pathConns.get(nk).top) conn.bottom = true;
            }

            allConns.set(key, conn);
        }
    }

    return allConns;
}

/** Select a room template for a given cell based on required connections and column-based difficulty */
function selectRoomForCell(col, row, required, cols, rng) {
    // Difficulty tier based on column position (early = easy, late = hard)
    const colFrac = col / (cols - 1);
    const targetDiff = colFrac < 0.33 ? 1 : (colFrac < 0.66 ? 2 : 3);

    // If no connections required, use dead_end
    if (!required.left && !required.right && !required.top && !required.bottom) {
        return ROOM_TEMPLATES.find(t => t.id === 'dead_end');
    }

    // Prefer exact connection matches (no extra openings into solid walls)
    const exact = ROOM_TEMPLATES.filter(t => {
        if (t.id === 'dead_end') return false;
        return t.connections.left === required.left &&
               t.connections.right === required.right &&
               t.connections.top === required.top &&
               t.connections.bottom === required.bottom;
    });

    const candidates = exact.length > 0 ? exact : ROOM_TEMPLATES.filter(t => {
        // Fallback: superset match (has all required, may have extras)
        if (t.id === 'dead_end') return false;
        if (required.left && !t.connections.left) return false;
        if (required.right && !t.connections.right) return false;
        if (required.top && !t.connections.top) return false;
        if (required.bottom && !t.connections.bottom) return false;
        return true;
    });

    if (candidates.length === 0) {
        // Fallback: flat_ground (always has L+R)
        return ROOM_TEMPLATES.find(t => t.id === 'flat_ground');
    }

    // Weight by difficulty proximity (closer to target = higher weight)
    const weights = candidates.map(t => {
        const diff = Math.abs(t.difficulty - targetDiff);
        return Math.max(0.1, 3 - diff);
    });
    const total = weights.reduce((s, w) => s + w, 0);
    let roll = rng() * total;
    for (let i = 0; i < candidates.length; i++) {
        roll -= weights[i];
        if (roll <= 0) return candidates[i];
    }
    return candidates[candidates.length - 1];
}

/** Select room templates for every cell in the grid */
function selectAllRooms(allConns, cols, rows, rng) {
    const roomGrid = [];
    for (let r = 0; r < rows; r++) {
        roomGrid[r] = [];
        for (let c = 0; c < cols; c++) {
            const key = `${c},${r}`;
            const required = allConns.get(key) || { left: false, right: false, top: false, bottom: false };
            roomGrid[r][c] = selectRoomForCell(c, r, required, cols, rng);
        }
    }
    return roomGrid;
}

/** Stamp room templates into a full tile grid */
function assembleRoomGrid(roomGrid, totalW, totalH) {
    const grid = [];
    for (let y = 0; y < totalH; y++) {
        grid[y] = [];
        for (let x = 0; x < totalW; x++) grid[y][x] = false;
    }

    for (let r = 0; r < GRID_ROWS; r++) {
        for (let c = 0; c < GRID_COLS; c++) {
            const template = roomGrid[r][c];
            const ox = c * ROOM_W;
            const oy = r * ROOM_H;
            for (let ty = 0; ty < ROOM_H; ty++) {
                for (let tx = 0; tx < ROOM_W; tx++) {
                    grid[oy + ty][ox + tx] = template.tiles[ty][tx] === '=';
                }
            }
        }
    }

    // Enforce connection zones between adjacent rooms
    for (let r = 0; r < GRID_ROWS; r++) {
        for (let c = 0; c < GRID_COLS; c++) {
            const template = roomGrid[r][c];
            const ox = c * ROOM_W;
            const oy = r * ROOM_H;

            // Left connection zone: cols 0-2, rows (H-6)..(H-2) empty, row (H-1) solid
            // 3 wide × 5 tall so the passage is clearly visible and easy to traverse
            if (template.connections.left) {
                for (let dx = 0; dx < 3; dx++) {
                    for (let dy = ROOM_H - 6; dy <= ROOM_H - 2; dy++) {
                        grid[oy + dy][ox + dx] = false;
                    }
                    grid[oy + ROOM_H - 1][ox + dx] = true;
                }
            }

            // Right connection zone: last 3 cols, rows (H-6)..(H-2) empty, row (H-1) solid
            if (template.connections.right) {
                for (let dx = ROOM_W - 3; dx < ROOM_W; dx++) {
                    for (let dy = ROOM_H - 6; dy <= ROOM_H - 2; dy++) {
                        grid[oy + dy][ox + dx] = false;
                    }
                    grid[oy + ROOM_H - 1][ox + dx] = true;
                }
            }

            // Top connection zone: rows 0-1, center 6 cols empty
            // 2 rows tall so the vertical passage between rooms is 4 tiles total
            if (template.connections.top) {
                for (let dx = ROOM_W / 2 - 3; dx < ROOM_W / 2 + 3; dx++) {
                    grid[oy][ox + dx] = false;
                    grid[oy + 1][ox + dx] = false;
                }
                // Stepping ledges at row 2 for jumping up: extend any template
                // platform to cover the gap edges so zombie can reach the ceiling
                grid[oy + 2][ox + ROOM_W / 2 - 3] = true;  // col 3 ledge
                grid[oy + 2][ox + ROOM_W / 2 + 2] = true;  // col 8 ledge
            }

            // Bottom connection zone: rows (H-2)..(H-1), center 6 cols empty
            // 2 rows tall so the vertical passage between rooms is 4 tiles total
            if (template.connections.bottom) {
                for (let dx = ROOM_W / 2 - 3; dx < ROOM_W / 2 + 3; dx++) {
                    grid[oy + ROOM_H - 1][ox + dx] = false;
                    grid[oy + ROOM_H - 2][ox + dx] = false;
                }
            }
        }
    }

    return grid;
}

/** Find valid standing positions within a room's tile area on the assembled grid.
 *  Avoids connection zones, single-tile platforms, and positions without headroom. */
function findRoomStandingPositions(roomCol, roomRow) {
    const positions = [];
    const ox = roomCol * ROOM_W;
    const oy = roomRow * ROOM_H;
    // Stay inside room interior: skip connection zone margins
    // Left/right: skip first 4 and last 4 cols (connection zones are 3 cols wide)
    // Top/bottom: skip first 3 and last 3 rows (connection zones are 2 rows deep)
    const margin = 4;
    const topMargin = 3;
    const botMargin = 3;
    for (let ty = topMargin; ty < ROOM_H - botMargin; ty++) {
        for (let tx = margin; tx < ROOM_W - margin; tx++) {
            const wx = ox + tx;
            const wy = oy + ty;
            if (wy + 1 >= MAP_ROWS) continue;
            // Must be empty with solid ground below
            if (tileMap[wy][wx] || !tileMap[wy + 1][wx]) continue;
            // Require 2 tiles of headroom above (zombie is 1.5 tiles tall)
            if (wy - 1 >= 0 && tileMap[wy - 1][wx]) continue;
            // Require at least 2 solid tiles in a row under this position
            // (avoid isolated single-tile platforms)
            const hasNeighborGround =
                (wx > 0 && tileMap[wy + 1][wx - 1]) ||
                (wx + 1 < MAP_COLS && tileMap[wy + 1][wx + 1]);
            if (!hasNeighborGround) continue;
            positions.push({ col: wx, row: wy });
        }
    }
    return positions;
}

/** Place entities on valid ground positions, spread across the path */
function placeEntitiesFromRoomGrid(roomGrid, path, rng) {
    GameState.entities.civilians = [];
    GameState.entities.guards = [];

    const pathSet = new Set(path.map(p => `${p.col},${p.row}`));

    // Deduplicate path cells (path can revisit same cell via vertical moves)
    const uniquePath = [];
    const seen = new Set();
    for (const cell of path) {
        const key = `${cell.col},${cell.row}`;
        if (!seen.has(key)) { seen.add(key); uniquePath.push(cell); }
    }

    // Collect valid standing positions for each path room
    const pathRoomPositions = [];
    for (const cell of uniquePath) {
        const template = roomGrid[cell.row][cell.col];
        if (template.id === 'dead_end' || template.id === 'vertical_shaft') continue;
        const positions = findRoomStandingPositions(cell.col, cell.row);
        if (positions.length > 0) {
            pathRoomPositions.push({ cell, positions });
        }
    }

    // Place civilians: every 2nd path room, cap at 10
    const civTarget = Math.min(10, Math.ceil(pathRoomPositions.length / 2));
    const civSpacing = Math.max(1, Math.floor(pathRoomPositions.length / civTarget));
    for (let i = 0; i < civTarget && i * civSpacing < pathRoomPositions.length; i++) {
        const room = pathRoomPositions[i * civSpacing];
        const pos = room.positions[Math.floor(rng() * room.positions.length)];
        const px = pos.col * TILE_SIZE + (TILE_SIZE - 24) / 2;
        const py = pos.row * TILE_SIZE + TILE_SIZE - 24;
        GameState.entities.civilians.push(createCivilian(px, py));
    }

    // Place 1-2 bonus civilians in off-path rooms
    const offPathRooms = [];
    for (let r = 0; r < GRID_ROWS; r++) {
        for (let c = 0; c < GRID_COLS; c++) {
            if (pathSet.has(`${c},${r}`)) continue;
            const template = roomGrid[r][c];
            if (template.id === 'dead_end') continue;
            const positions = findRoomStandingPositions(c, r);
            if (positions.length > 0) offPathRooms.push({ col: c, row: r, positions });
        }
    }
    for (let i = offPathRooms.length - 1; i > 0; i--) {
        const j = Math.floor(rng() * (i + 1));
        [offPathRooms[i], offPathRooms[j]] = [offPathRooms[j], offPathRooms[i]];
    }
    for (let i = 0; i < Math.min(5, offPathRooms.length); i++) {
        const room = offPathRooms[i];
        const pos = room.positions[Math.floor(rng() * room.positions.length)];
        const px = pos.col * TILE_SIZE + (TILE_SIZE - 24) / 2;
        const py = pos.row * TILE_SIZE + TILE_SIZE - 24;
        GameState.entities.civilians.push(createCivilian(px, py));
    }

    // Place guards near civilians so they can guard them.
    // Pick civilians to guard, then find a standing position on the same ground row
    // a few tiles away. This guarantees areSamePlatform() succeeds for assignGuards().
    const civs = [...GameState.entities.civilians];
    for (let i = civs.length - 1; i > 0; i--) {
        const j = Math.floor(rng() * (i + 1));
        [civs[i], civs[j]] = [civs[j], civs[i]];
    }
    const guardCount = Math.min(6, civs.length);
    for (let i = 0; i < guardCount; i++) {
        const civ = civs[i];
        const civCol = Math.floor(civ.x / TILE_SIZE);
        const civFootRow = Math.floor((civ.y + civ.height) / TILE_SIZE);
        // Search for a standing position 2-6 tiles to either side on the same ground row
        let placed = false;
        const offsets = [3, -3, 4, -4, 2, -2, 5, -5, 6, -6];
        for (const off of offsets) {
            const tx = civCol + off;
            if (tx < 0 || tx >= MAP_COLS) continue;
            const standRow = civFootRow - 1;
            if (standRow < 0 || standRow >= MAP_ROWS) continue;
            // Must be empty with solid ground below, and have headroom
            if (tileMap[standRow][tx]) continue;
            if (!tileMap[civFootRow][tx]) continue;
            if (standRow > 0 && tileMap[standRow - 1][tx]) continue;
            const px = tx * TILE_SIZE + (TILE_SIZE - 32) / 2;
            const py = standRow * TILE_SIZE + TILE_SIZE - 32;
            GameState.entities.guards.push(createGuard(px, py));
            placed = true;
            break;
        }
        // Fallback: spawn directly at civilian position if no offset works
        if (!placed) {
            const px = civ.x + (civ.width - 32) / 2;
            const py = civ.y + civ.height - 32;
            GameState.entities.guards.push(createGuard(px, py));
        }
    }

    assignGuards(GameState);
}

/** Generate a level using the room-grid system */
function generateLevel(width, height, density, minSanity, seed) {
    const rng = splitmix32(seed);
    const { maxUpTiles, maxAcrossTiles } = calcJumpEnvelope(minSanity);

    // 1. Generate critical path
    const { path, connections } = generateCriticalPath(GRID_COLS, GRID_ROWS, rng);

    // 2. Add exploration side-branches off the critical path
    const branchCells = addSideBranches(path, connections, GRID_COLS, GRID_ROWS, rng);

    // 3. Determine required connections for all cells (path + branches + neighbors)
    const allConns = computeAllCellConnections(path, connections, GRID_COLS, GRID_ROWS);

    // 4. Select room template for each cell
    const roomGrid = selectAllRooms(allConns, GRID_COLS, GRID_ROWS, rng);

    // 5. Assemble into tile grid
    const totalW = GRID_COLS * ROOM_W;
    const totalH = GRID_ROWS * ROOM_H;
    const grid = assembleRoomGrid(roomGrid, totalW, totalH);

    // 6. Skip BFS validation — room templates are hand-designed with
    // intentional platforms. The old BFS seeds from the absolute grid
    // bottom and can't reach rooms surrounded by solid dead_end walls.

    // Store room grid data for entity placement
    generateLevel._lastRoomGrid = roomGrid;
    generateLevel._lastPath = path;
    generateLevel._lastRng = rng;

    return grid;
}

/** Resize canvas to match current map dimensions */
function resizeCanvas() {
    canvas.width = MAP_COLS * TILE_SIZE;
    canvas.height = MAP_ROWS * TILE_SIZE;
    document.getElementById('sanity-bar').style.maxWidth = (MAP_COLS * TILE_SIZE + 4) + 'px';
}

/** Find a valid spawn point and place the zombie there */
function findAndSetSpawn() {
    // If we have path data, spawn in the first critical-path room
    if (generateLevel._lastPath && generateLevel._lastPath.length > 0) {
        const room = generateLevel._lastPath[0];
        if (spawnInRoom(room.col, room.row)) return;
    }
    // Fallback: scan leftmost columns globally
    for (let col = 0; col < MAP_COLS; col++) {
        for (let row = MAP_ROWS - 1; row >= 0; row--) {
            if (!tileMap[row][col]) continue;
            const h1 = row - 1, h2 = row - 2;
            if (h1 >= 0 && !tileMap[h1][col] && h2 >= 0 && !tileMap[h2][col]) {
                zombie.x = col * TILE_SIZE;
                zombie.y = row * TILE_SIZE - zombie.height;
                zombie.vx = 0;
                zombie.vy = 0;
                zombie.grounded = false;
                return;
            }
        }
    }
}

/** Spawn the zombie in a specific room on the grid */
function spawnInRoom(roomCol, roomRow) {
    const ox = roomCol * ROOM_W;
    const oy = roomRow * ROOM_H;
    for (let ty = ROOM_H - 1; ty >= 0; ty--) {
        for (let tx = 2; tx < ROOM_W - 2; tx++) {
            const col = ox + tx;
            const row = oy + ty;
            if (row < 2 || row >= MAP_ROWS) continue;
            if (!tileMap[row][col]) continue;
            if (!tileMap[row - 1][col] && !tileMap[row - 2][col]) {
                zombie.x = col * TILE_SIZE;
                zombie.y = row * TILE_SIZE - zombie.height;
                zombie.vx = 0;
                zombie.vy = 0;
                zombie.grounded = false;
                return true;
            }
        }
    }
    return false;
}

/** Apply a generated grid as the active level */
function applyLevel(grid, width, height) {
    currentLevel = 'generated';
    MAP_COLS = width;
    MAP_ROWS = height;
    tileMap = grid;
    // Build MAP_DATA strings for consistency
    MAP_DATA = grid.map(row => row.map(v => v ? '=' : '.').join(''));
    resizeCanvas();
    findAndSetSpawn();
    // Place entities from room grid data
    if (typeof GameState !== 'undefined') {
        if (generateLevel._lastRoomGrid && generateLevel._lastPath && generateLevel._lastRng) {
            placeEntitiesFromRoomGrid(generateLevel._lastRoomGrid, generateLevel._lastPath, generateLevel._lastRng);
        } else {
            GameState.entities.civilians = [];
            GameState.entities.guards = [];
        }
        // Place exit in last path room if available
        if (generateLevel._lastPath && generateLevel._lastPath.length > 0) {
            const lastRoom = generateLevel._lastPath[generateLevel._lastPath.length - 1];
            if (!setExitInRoom(lastRoom.col, lastRoom.row)) {
                if (typeof findAndSetExit === 'function') findAndSetExit();
            }
        } else if (typeof findAndSetExit === 'function') {
            findAndSetExit();
        }
    }
}

/** Place the exit in a specific room on the grid */
function setExitInRoom(roomCol, roomRow) {
    const ox = roomCol * ROOM_W;
    const oy = roomRow * ROOM_H;
    for (let tx = ROOM_W - 3; tx >= 2; tx--) {
        for (let ty = ROOM_H - 1; ty >= 0; ty--) {
            const col = ox + tx;
            const row = oy + ty;
            if (row < 2 || row >= MAP_ROWS) continue;
            if (!tileMap[row][col]) continue;
            if (!tileMap[row - 1][col] && !tileMap[row - 2][col]) {
                GameState.level.exit.x = col * TILE_SIZE;
                GameState.level.exit.y = (row - 2) * TILE_SIZE;
                GameState.level.exit.width = 32;
                GameState.level.exit.height = 64;
                return true;
            }
        }
    }
    return false;
}

/** Restore the hardcoded Sanity Gauntlet map */
function loadPresetGauntlet() {
    currentLevel = 'gauntlet';
    MAP_COLS = 40;
    MAP_ROWS = 25;
    MAP_DATA = [...PRESET_GAUNTLET];
    tileMap = MAP_DATA.map(row => Array.from(row).map(ch => ch === '='));
    resizeCanvas();
    findAndSetSpawn();
    // Repopulate entities for the Gauntlet map
    if (typeof placeCiviliansOnGauntlet === 'function') placeCiviliansOnGauntlet();
    if (typeof placeGuardsOnMap === 'function') { placeGuardsOnMap(); assignGuards(GameState); }
    if (typeof findAndSetExit === 'function') findAndSetExit();
}

/** Place civilians and guards from a level data object with explicit positions */
function placeEntitiesFromLevelData(levelData) {
    GameState.entities.civilians = [];
    GameState.entities.guards = [];

    for (const c of levelData.civilians) {
        // Civilians are 24px tall, placed centered in tile, standing on surface
        const px = c.col * TILE_SIZE + (TILE_SIZE - 24) / 2;
        const py = (c.row - 1) * TILE_SIZE + TILE_SIZE - 24;
        GameState.entities.civilians.push(createCivilian(px, py));
    }

    for (const t of levelData.guards) {
        // Guards are 32px tall, placed at tile top of the row above ground
        const px = t.col * TILE_SIZE;
        const py = (t.row - 1) * TILE_SIZE;
        GameState.entities.guards.push(createGuard(px, py));
    }

    assignGuards(GameState);
}

/** Load Level 1: purpose-built level for the vertical slice */
function loadLevel1() {
    currentLevel = 'level1';
    MAP_COLS = LEVEL_1.cols;
    MAP_ROWS = LEVEL_1.rows;
    MAP_DATA = [...LEVEL_1.map];
    tileMap = MAP_DATA.map(row => Array.from(row).map(ch => ch === '='));
    resizeCanvas();
    findAndSetSpawn();
    placeEntitiesFromLevelData(LEVEL_1);
    findAndSetExit();
}

/** UI: Generate room-grid level with current slider values */
function doGenerate() {
    const density = parseInt(document.getElementById('gen-density').value) / 100;
    const minSanity = parseInt(document.getElementById('gen-sanity').value);
    const seed = parseInt(document.getElementById('gen-seed').value) || 42;
    const totalW = GRID_COLS * ROOM_W;
    const totalH = GRID_ROWS * ROOM_H;
    const grid = generateLevel(totalW, totalH, density, minSanity, seed);
    applyLevel(grid, totalW, totalH);
}

/** UI: Random seed then generate */
function doRandomGenerate() {
    const seed = Math.floor(Math.random() * 999999);
    document.getElementById('gen-seed').value = seed;
    doGenerate();
}

// ============================================================
// GAME STATE
// Mutable runtime state. Kept separate from constants so the
// tuning panel only touches the constants section above.
// ============================================================

const zombie = {
    x: 32,              // spawn position — bottom left, one tile in
    y: (MAP_ROWS - 2) * TILE_SIZE,  // one tile above ground
    width: 32,
    height: 48,
    vx: 0,
    vy: 0,
    grounded: false,
    coyoteTimer: 0,      // time since last grounded (for coyote time)
    jumpBufferTimer: 0,  // time since jump was pressed (for jump buffering)
    wasGrounded: false,   // grounded state from previous frame
    jumpCut: false,       // true after variable-height cut fires (prevents repeated cuts)
    scaleX: 1,            // squash/stretch horizontal (1.0 = normal)
    scaleY: 1,            // squash/stretch vertical (1.0 = normal)
    lastVy: 0,            // vy at moment of landing (for intensity scaling)
    hp: 5,               // current hit points
    maxHP: 5,            // maximum hit points
    invincibleTimer: 0,  // seconds of iframes remaining
};

let sanity = 12;

// Input state
const input = {
    left: false,
    right: false,
    jump: false,
    jumpPressed: false,   // true only on the frame jump is first pressed
    jumpHeld: false,      // true while jump key is held
};

// Drift state
const drift = {
    timer: 0,
    nextInterval: 1.0,    // seconds until next drift impulse
    inputDelayTimer: 0,   // Feral-only: remaining input delay
    inputDelayDirection: 0, // which direction was blocked (-1 left, 1 right, 0 none)
    flashTimer: 0,        // visual feedback: counts down after drift fires
    flashDirection: 0,    // which side drift pushed toward (-1 left, 1 right)
    lastImpulse: 0,       // magnitude of most recent drift impulse (for rendering)
};

// Juice state — particles, camera shake
// Architecture note: particles are a flat array rather than a linked
// list because the count is small (< 30 at any time) and array
// iteration is cache-friendly. Camera shake uses exponential decay
// for natural-feeling falloff.
const particles = [];
const camera = {
    shakeX: 0,
    shakeY: 0,
    shakeIntensity: 0,
    shakeDuration: 0,
    shakeTimer: 0,
    shakeBiasX: 0,        // directional bias (-1 left, 0 neutral, 1 right)
};

// ============================================================
// GAME STATE
// Centralized state object (Strangler Fig migration steps 0+1).
// References existing globals for now — bare `zombie` and `sanity`
// remain as sources of truth during Sprint 1. New systems read/write
// through GameState; existing systems read globals directly.
// ============================================================

let GameState = {
    phase: 'PLAYING',
    zombie: zombie,
    sanity: {
        value: sanity,
        maxValue: 12,
        drainEnabled: false,   // off by default (toy mode preserved)
    },
    entities: {
        civilians: [],
        guards: [],
    },
    level: {
        tileMap: tileMap,
        cols: MAP_COLS,
        rows: MAP_ROWS,
        exit: { x: 0, y: 0, width: 32, height: 64 },
    },
    stats: {
        timeElapsed: 0,
        civiliansEaten: 0,
        damagesTaken: 0,
        guardsPounced: 0,
    },
};

// ============================================================
// GAME PHASE MACHINE
// Manages state transitions. Gates which update systems run per
// phase. The game loop keeps running in ALL phases — only update
// systems are gated behind PLAYING. Rendering always runs.
// ============================================================

const gameOverHpOverlay = document.getElementById('game-over-hp-overlay');
const goneOverlay = document.getElementById('gone-overlay');
const levelCompleteOverlay = document.getElementById('level-complete-overlay');
const levelCompleteStats = document.getElementById('level-complete-stats');

function updateGamePhase(state) {
    switch (state.phase) {
        case 'PLAYING':
            // End-condition checks: HP before sanity (edge case #3)
            if (state.zombie.hp <= 0) {
                state.phase = 'GAME_OVER_HP';
                break;
            }
            if (sanity <= 0) {
                state.phase = 'GAME_OVER_SANITY';
                break;
            }
            if (checkExitZone(state)) {
                state.phase = 'LEVEL_COMPLETE';
                // Populate stats overlay
                const mins = Math.floor(state.stats.timeElapsed / 60);
                const secs = Math.floor(state.stats.timeElapsed % 60);
                const timeStr = `${mins}:${secs.toString().padStart(2, '0')}`;
                const totalCivs = state.entities.civilians.length;
                levelCompleteStats.innerHTML = [
                    `Time: ${timeStr}`,
                    `Civilians Eaten: ${state.stats.civiliansEaten} / ${totalCivs}`,
                    `HP Remaining: ${state.zombie.hp} / ${state.zombie.maxHP}`,
                    `Guards Pounced: ${state.stats.guardsPounced}`,
                ].join('<br>');
                levelCompleteOverlay.classList.add('active');
                break;
            }
            break;

        case 'GAME_OVER_SANITY':
            goneOverlay.classList.add('active');
            if (keysDown.has('r') || keysDown.has('R')) {
                resetGameState();
            }
            break;

        case 'GAME_OVER_HP':
            gameOverHpOverlay.classList.add('active');
            if (keysDown.has('r') || keysDown.has('R')) {
                resetGameState();
            }
            break;

        case 'LEVEL_COMPLETE':
            if (keysDown.has('r') || keysDown.has('R')) {
                resetGameState();
            }
            break;
    }
}

function resetGameState() {
    // Reset zombie
    findAndSetSpawn();
    zombie.hp = ZOMBIE_MAX_HP;
    zombie.maxHP = ZOMBIE_MAX_HP;
    zombie.invincibleTimer = 0;
    zombie.scaleX = 1;
    zombie.scaleY = 1;
    zombie.jumpCut = false;
    zombie.coyoteTimer = 0;
    zombie.jumpBufferTimer = 0;
    zombie.wasGrounded = false;
    zombie.lastVy = 0;

    // Reset sanity
    sanity = 12;
    GameState.sanity.value = 12;
    sanitySlider.value = 12;

    // Reset entities — use level-specific placement
    GameState.entities.civilians = [];
    GameState.entities.guards = [];
    if (currentLevel === 'level1') {
        placeEntitiesFromLevelData(LEVEL_1);
    } else if (currentLevel === 'generated' && generateLevel._lastRoomGrid) {
        const entityRng = splitmix32((parseInt(document.getElementById('gen-seed').value) || 42) + 7);
        placeEntitiesFromRoomGrid(generateLevel._lastRoomGrid, generateLevel._lastPath, entityRng);
    } else {
        placeCiviliansOnGauntlet();
        placeGuardsOnMap();
        assignGuards(GameState);
    }

    // Reset stats
    GameState.stats.timeElapsed = 0;
    GameState.stats.civiliansEaten = 0;
    GameState.stats.damagesTaken = 0;
    GameState.stats.guardsPounced = 0;

    // Reset drift
    drift.timer = 0;
    drift.nextInterval = 1.0;
    drift.inputDelayTimer = 0;
    drift.inputDelayDirection = 0;
    drift.flashTimer = 0;
    drift.flashDirection = 0;
    drift.lastImpulse = 0;

    // Clear particles and shake
    particles.length = 0;
    camera.shakeX = 0;
    camera.shakeY = 0;
    camera.shakeIntensity = 0;
    camera.shakeDuration = 0;
    camera.shakeTimer = 0;
    camera.shakeBiasX = 0;

    // Place exit zone
    findAndSetExit();

    // Clear overlays
    goneOverlay.classList.remove('active');
    gameOverHpOverlay.classList.remove('active');
    levelCompleteOverlay.classList.remove('active');

    // Resume play
    GameState.phase = 'PLAYING';

    updateSanityUI();
}

// ============================================================
// HEALTH SYSTEM
// HP tracking, damage with invincibility frames, iframe timer.
// ============================================================

function damageZombie(state, amount) {
    if (state.zombie.invincibleTimer > 0) return;
    state.zombie.hp = Math.max(0, state.zombie.hp - amount);
    state.zombie.invincibleTimer = INVINCIBILITY_DURATION;
    state.stats.damagesTaken++;
    triggerShake(3, 0.1);
}

function updateHealth(state, dt) {
    if (state.zombie.invincibleTimer > 0) {
        state.zombie.invincibleTimer = Math.max(0, state.zombie.invincibleTimer - dt);
    }
}

// ============================================================
// SANITY DRAIN
// Continuous sanity drain when auto-drain is enabled.
// ============================================================

function updateSanityDrain(state, dt) {
    if (!state.sanity.drainEnabled) return;
    sanity = Math.max(0, sanity - SANITY_DRAIN_RATE * dt);
    state.sanity.value = sanity;
    sanitySlider.value = sanity;
}

// ============================================================
// CIVILIAN SYSTEM
// Civilian entities with flee/seek/wander AI. Civilians are the
// zombie's food source — walking, fleeing rectangles that must
// be caught and eaten to restore sanity.
// ============================================================

function createCivilian(x, y) {
    return {
        x: x, y: y,
        width: 24, height: 24,
        vx: 0,
        alive: true,
        state: 'WANDER',
        facingRight: Math.random() < 0.5,
        wanderTimer: 0,
    };
}

/** Find all valid standing positions on the current tile map.
 *  A valid position is an empty tile with a solid tile directly below. */
function findStandingPositions() {
    const positions = [];
    for (let row = 1; row < MAP_ROWS; row++) {
        for (let col = 1; col < MAP_COLS - 1; col++) {
            if (!tileMap[row][col] && tileMap[row + 1] && isSolid(col, row + 1)) {
                positions.push({ col, row });
            }
        }
    }
    return positions;
}

/** Place 5 civilians on valid ground positions, spread across the map */
function placeCiviliansOnGauntlet() {
    GameState.entities.civilians = [];
    const positions = findStandingPositions();
    if (positions.length === 0) return;

    // Sort by column so we can spread civilians across the map
    positions.sort((a, b) => a.col - b.col);

    // Pick 5 evenly spaced positions
    const count = Math.min(5, positions.length);
    for (let i = 0; i < count; i++) {
        const idx = Math.floor((i + 0.5) * positions.length / count);
        const pos = positions[idx];
        const px = pos.col * TILE_SIZE + (TILE_SIZE - 24) / 2;
        const py = pos.row * TILE_SIZE + TILE_SIZE - 24;
        GameState.entities.civilians.push(createCivilian(px, py));
    }
}

function updateCivilians(state, dt) {
    for (const civ of state.entities.civilians) {
        if (!civ.alive) continue;

        const dx = state.zombie.x + state.zombie.width / 2 - (civ.x + civ.width / 2);
        const dy = state.zombie.y + state.zombie.height / 2 - (civ.y + civ.height / 2);
        const dist = Math.sqrt(dx * dx + dy * dy);

        // AI priority: FLEE > SEEK (placeholder) > WANDER
        if (dist < CIVILIAN_FLEE_RANGE) {
            civ.state = 'FLEE';
            // Flee away from zombie
            const fleeDir = dx > 0 ? -1 : 1;
            civ.vx = fleeDir * CIVILIAN_FLEE_SPEED;
            civ.facingRight = fleeDir > 0;
        } else {
            // WANDER: slow random patrol
            civ.state = 'WANDER';
            civ.wanderTimer -= dt;
            if (civ.wanderTimer <= 0) {
                civ.facingRight = Math.random() < 0.5;
                civ.wanderTimer = 1.5 + Math.random() * 2.0;
            }
            civ.vx = (civ.facingRight ? 1 : -1) * CIVILIAN_WANDER_SPEED;
        }

        // Edge avoidance: check ground ahead and wall ahead
        const moveDir = civ.vx > 0 ? 1 : -1;
        const checkX = moveDir > 0 ? civ.x + civ.width : civ.x - 1;
        const checkCol = Math.floor(checkX / TILE_SIZE);
        const footRow = Math.floor((civ.y + civ.height) / TILE_SIZE);
        const headRow = Math.floor(civ.y / TILE_SIZE);

        // No ground ahead — reverse
        const hasGround = checkCol >= 0 && checkCol < MAP_COLS && footRow < MAP_ROWS && isSolid(checkCol, footRow);
        // Wall ahead — reverse
        const hasWall = checkCol >= 0 && checkCol < MAP_COLS && isSolid(checkCol, headRow);

        if (!hasGround || hasWall) {
            civ.vx = -civ.vx;
            civ.facingRight = !civ.facingRight;
            if (civ.state === 'WANDER') {
                civ.wanderTimer = 1.0 + Math.random() * 1.5;
            }
        }

        // Apply movement
        civ.x += civ.vx * dt;

        // World boundary clamp
        if (civ.x < 0) { civ.x = 0; civ.vx = Math.abs(civ.vx); civ.facingRight = true; }
        if (civ.x + civ.width > MAP_COLS * TILE_SIZE) {
            civ.x = MAP_COLS * TILE_SIZE - civ.width;
            civ.vx = -Math.abs(civ.vx);
            civ.facingRight = false;
        }
    }
}

function renderCivilians(state) {
    for (const civ of state.entities.civilians) {
        if (!civ.alive) continue;
        // Orange when fleeing, cyan when wandering
        ctx.fillStyle = civ.state === 'FLEE' ? '#ff6b35' : '#00ddff';
        ctx.fillRect(civ.x, civ.y, civ.width, civ.height);
        // "C" label
        ctx.fillStyle = '#000';
        ctx.font = 'bold 14px Consolas, monospace';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText('C', civ.x + civ.width / 2, civ.y + civ.height / 2);
    }
}

// ============================================================
// EAT COLLISION + DEATH SCREAM
// AABB overlap check for zombie eating civilians. On eat:
// civilian dies, sanity restores, death scream broadcasts.
// ============================================================

function aabbOverlap(a, b) {
    return a.x < b.x + b.width &&
           a.x + a.width > b.x &&
           a.y < b.y + b.height &&
           a.y + a.height > b.y;
}

function checkEatCollision(state) {
    for (const civ of state.entities.civilians) {
        if (!civ.alive) continue;
        if (aabbOverlap(state.zombie, civ)) {
            // Consume civilian
            civ.alive = false;

            // Restore sanity (cap at 12)
            sanity = Math.min(12, sanity + SANITY_PER_EAT);
            state.sanity.value = sanity;
            sanitySlider.value = sanity;

            // Stats
            state.stats.civiliansEaten++;

            // Death scream
            broadcastScream(state, civ.x + civ.width / 2, civ.y + civ.height / 2);

            // Reassign guards (eaten civilian's guard needs a new assignment)
            assignGuards(state);

            // Visual feedback: particles + shake
            emitDust(civ.x + civ.width / 2, civ.y + civ.height / 2, 6, 0, 60);
            triggerShake(2, 0.1);

            // Update sanity UI immediately
            updateSanityUI();
        }
    }
}

function broadcastScream(state, x, y) {
    // Alert all guards within scream range
    for (const guard of state.entities.guards) {
        if (!guard.alive) continue;
        const dx = guard.x + guard.width / 2 - x;
        const dy = guard.y + guard.height / 2 - y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        if (dist <= SCREAM_ALERT_RANGE) {
            guard.state = 'RESPONDING_TO_SCREAM';
            guard.alertTarget = { x: x, y: y };
            guard.alertTimer = SCREAM_ALERT_DURATION;
        }
    }
    triggerShake(1.5, 0.08);
}

// ============================================================
// GUARD SYSTEM
// Guard entities guard civilians and chase the zombie. AI states:
// GUARD_PATROL — patrol near assigned civilian (or patrolCenter)
// CHASE — pursue zombie within leash distance
// RESPONDING_TO_SCREAM — move to scream location on alert
// ============================================================

function createGuard(x, y) {
    return {
        x: x, y: y,
        width: 32, height: 32,
        vx: 0,
        alive: true,
        state: 'GUARD_PATROL',
        guardedCivilian: null,
        patrolCenter: x,
        alertTimer: 0,
        alertTarget: { x: 0, y: 0 },
        facingRight: true,
    };
}

/** Check if two entities share continuous ground on the same row */
function areSamePlatform(entityA, entityB) {
    const rowA = Math.floor((entityA.y + entityA.height) / TILE_SIZE);
    const rowB = Math.floor((entityB.y + entityB.height) / TILE_SIZE);
    if (rowA !== rowB) return false;

    const colA = Math.floor((entityA.x + entityA.width / 2) / TILE_SIZE);
    const colB = Math.floor((entityB.x + entityB.width / 2) / TILE_SIZE);
    const minCol = Math.min(colA, colB);
    const maxCol = Math.max(colA, colB);

    for (let c = minCol; c <= maxCol; c++) {
        if (!isSolid(c, rowA)) return false;
    }
    return true;
}

/** Assign each guard to guard the nearest alive same-platform civilian.
 *  Prefer civilians not already guarded by 2+ guards. */
function assignGuards(state) {
    // Count guards per civilian
    const guardCounts = new Map();
    for (const guard of state.entities.guards) {
        if (!guard.alive) continue;
        guard.guardedCivilian = null;
    }

    for (const guard of state.entities.guards) {
        if (!guard.alive) continue;

        let bestCiv = null;
        let bestDist = Infinity;

        for (const civ of state.entities.civilians) {
            if (!civ.alive) continue;
            if (!areSamePlatform(guard, civ)) continue;

            const count = guardCounts.get(civ) || 0;
            const dx = guard.x - civ.x;
            const dy = guard.y - civ.y;
            const dist = Math.sqrt(dx * dx + dy * dy);

            // Prefer civilians with fewer guards, then nearest
            if (bestCiv === null ||
                count < (guardCounts.get(bestCiv) || 0) ||
                (count === (guardCounts.get(bestCiv) || 0) && dist < bestDist)) {
                bestCiv = civ;
                bestDist = dist;
            }
        }

        guard.guardedCivilian = bestCiv;
        if (bestCiv) {
            guard.patrolCenter = bestCiv.x + bestCiv.width / 2;
            guardCounts.set(bestCiv, (guardCounts.get(bestCiv) || 0) + 1);
        }
    }
}

function updateGuards(state, dt) {
    for (const guard of state.entities.guards) {
        if (!guard.alive) continue;

        const zx = state.zombie.x + state.zombie.width / 2;
        const zy = state.zombie.y + state.zombie.height / 2;
        const tx = guard.x + guard.width / 2;
        const ty = guard.y + guard.height / 2;
        const distToZombie = Math.sqrt((zx - tx) * (zx - tx) + (zy - ty) * (zy - ty));

        // Leash anchor: guarded civilian's center, or patrolCenter
        let anchorX = guard.patrolCenter;
        if (guard.guardedCivilian && guard.guardedCivilian.alive) {
            anchorX = guard.guardedCivilian.x + guard.guardedCivilian.width / 2;
            guard.patrolCenter = anchorX;
        }
        const distFromAnchor = Math.abs(tx - anchorX);

        // AI priority: RESPONDING_TO_SCREAM > CHASE > GUARD_PATROL
        if (guard.state === 'RESPONDING_TO_SCREAM') {
            // Move toward alert target
            const dx = guard.alertTarget.x - tx;
            if (Math.abs(dx) > 4) {
                guard.vx = Math.sign(dx) * GUARD_CHASE_SPEED;
                guard.facingRight = dx > 0;
            } else {
                guard.vx = 0;
            }
            guard.alertTimer -= dt;
            if (guard.alertTimer <= 0 || Math.abs(dx) <= 4) {
                guard.state = 'GUARD_PATROL';
                guard.alertTimer = 0;
            }
        } else if (distToZombie < GUARD_DETECTION_RANGE && distFromAnchor < GUARD_LEASH_DISTANCE) {
            // CHASE
            guard.state = 'CHASE';
            const dx = zx - tx;
            guard.vx = Math.sign(dx) * GUARD_CHASE_SPEED;
            guard.facingRight = dx > 0;

            // Break chase if too far from anchor
            if (distFromAnchor >= GUARD_LEASH_DISTANCE) {
                guard.state = 'GUARD_PATROL';
            }
        } else {
            // GUARD_PATROL
            guard.state = 'GUARD_PATROL';
            const patrolRange = guard.guardedCivilian && guard.guardedCivilian.alive
                ? GUARD_WATCH_RANGE : GUARD_PATROL_RANGE;

            // Patrol back and forth around anchor
            const distToAnchor = tx - anchorX;
            if (Math.abs(distToAnchor) > patrolRange) {
                // Beyond patrol range — reverse toward anchor
                guard.vx = distToAnchor > 0 ? -GUARD_SPEED : GUARD_SPEED;
                guard.facingRight = guard.vx > 0;
            } else if (guard.vx === 0) {
                // Start patrolling
                guard.vx = (guard.facingRight ? 1 : -1) * GUARD_SPEED;
            } else {
                // Continue patrolling at patrol speed
                guard.vx = Math.sign(guard.vx) * GUARD_SPEED;
            }
        }

        // Edge avoidance: check ground ahead and wall ahead
        const moveDir = guard.vx > 0 ? 1 : -1;
        const checkX = moveDir > 0 ? guard.x + guard.width : guard.x - 1;
        const checkCol = Math.floor(checkX / TILE_SIZE);
        const footRow = Math.floor((guard.y + guard.height) / TILE_SIZE);
        const headRow = Math.floor(guard.y / TILE_SIZE);

        const hasGround = checkCol >= 0 && checkCol < MAP_COLS && footRow < MAP_ROWS && isSolid(checkCol, footRow);
        const hasWall = checkCol >= 0 && checkCol < MAP_COLS && isSolid(checkCol, headRow);

        if (!hasGround || hasWall) {
            guard.vx = -guard.vx;
            guard.facingRight = !guard.facingRight;
        }

        // Apply movement
        guard.x += guard.vx * dt;

        // World boundary clamp
        if (guard.x < 0) { guard.x = 0; guard.vx = Math.abs(guard.vx); guard.facingRight = true; }
        if (guard.x + guard.width > MAP_COLS * TILE_SIZE) {
            guard.x = MAP_COLS * TILE_SIZE - guard.width;
            guard.vx = -Math.abs(guard.vx);
            guard.facingRight = false;
        }
    }
}

function renderGuards(state) {
    for (const guard of state.entities.guards) {
        if (!guard.alive) continue;

        // Color by state: red (patrol), magenta (chase), yellow (scream response)
        if (guard.state === 'RESPONDING_TO_SCREAM') {
            ctx.fillStyle = '#ffdd00';
        } else if (guard.state === 'CHASE') {
            ctx.fillStyle = '#ff00ff';
        } else {
            ctx.fillStyle = '#ff3333';
        }
        ctx.fillRect(guard.x, guard.y, guard.width, guard.height);

        // Cyan outline when guarding a civilian
        if (guard.guardedCivilian && guard.guardedCivilian.alive) {
            ctx.strokeStyle = '#00ddff';
            ctx.lineWidth = 2;
            ctx.strokeRect(guard.x, guard.y, guard.width, guard.height);
        }

        // "!" label
        ctx.fillStyle = '#000';
        ctx.font = 'bold 16px Consolas, monospace';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText('!', guard.x + guard.width / 2, guard.y + guard.height / 2);
    }
}

/** Place guards on valid standing positions near civilians.
 *  Each guard picks the nearest same-row position to a civilian,
 *  offset by 2-4 tiles so it's nearby but not overlapping. */
function placeGuardsOnMap() {
    GameState.entities.guards = [];
    const positions = findStandingPositions();
    if (positions.length === 0) return;

    const civs = GameState.entities.civilians.filter(c => c.alive);
    const count = Math.min(3, positions.length);
    const usedCivIndices = new Set();

    for (let i = 0; i < count; i++) {
        // Pick a civilian to place near (spread across civilians, no repeats until all used)
        let targetCiv = null;
        if (civs.length > 0) {
            const civIdx = Math.floor((i + 0.5) * civs.length / count);
            // Prefer an unused civilian
            let chosen = civIdx;
            for (let try_ = 0; try_ < civs.length; try_++) {
                const candidate = (civIdx + try_) % civs.length;
                if (!usedCivIndices.has(candidate)) { chosen = candidate; break; }
            }
            usedCivIndices.add(chosen);
            targetCiv = civs[chosen];
        }

        let bestPos = null;
        let bestDist = Infinity;

        if (targetCiv) {
            const civCol = Math.floor((targetCiv.x + targetCiv.width / 2) / TILE_SIZE);
            const civRow = Math.floor((targetCiv.y + targetCiv.height) / TILE_SIZE);

            // Find nearest same-row position, 2-4 tiles away
            for (const pos of positions) {
                if (pos.row !== civRow - 1 && pos.row !== civRow) continue;
                const colDist = Math.abs(pos.col - civCol);
                if (colDist < 2 || colDist > 6) continue;
                if (colDist < bestDist) {
                    bestDist = colDist;
                    bestPos = pos;
                }
            }
            // Fallback: any same-row position near the civilian
            if (!bestPos) {
                for (const pos of positions) {
                    if (pos.row !== civRow - 1 && pos.row !== civRow) continue;
                    const colDist = Math.abs(pos.col - civCol);
                    if (colDist < bestDist) {
                        bestDist = colDist;
                        bestPos = pos;
                    }
                }
            }
        }

        // Final fallback: evenly spaced position
        if (!bestPos) {
            const idx = Math.floor((i + 0.5) * positions.length / count);
            bestPos = positions[idx];
        }

        const px = bestPos.col * TILE_SIZE + (TILE_SIZE - 32) / 2;
        const py = bestPos.row * TILE_SIZE + TILE_SIZE - 32;
        GameState.entities.guards.push(createGuard(px, py));
    }
}

// ============================================================
// GUARD COLLISION + POUNCE
// Zombie-guard overlap: at Feral (sanity < threshold) the
// zombie pounces and kills the guard. Otherwise, takes damage.
// ============================================================

function checkGuardCollision(state) {
    for (const guard of state.entities.guards) {
        if (!guard.alive) continue;
        if (!aabbOverlap(state.zombie, guard)) continue;

        if (sanity < POUNCE_SANITY_THRESHOLD) {
            // POUNCE — kill the guard
            guard.alive = false;
            state.stats.guardsPounced++;

            // Visual feedback: large particle burst + strong shake
            emitDust(guard.x + guard.width / 2, guard.y + guard.height / 2, 8, 0, 80);
            triggerShake(4, 0.15);

            // Reassign remaining guards
            assignGuards(state);
        } else {
            // DAMAGE — guard hurts zombie (respects iframes)
            damageZombie(state, GUARD_DAMAGE);
        }
    }
}

// ============================================================
// LEVEL ZONES
// Exit zone detection and rendering. The exit is a gold rectangle
// on the right side of the map. Walking into it completes the level.
// ============================================================

/** Find a valid exit position on the right side of the map */
function findAndSetExit() {
    // Scan rightmost columns for a valid 2-tile-high space above solid ground
    for (let col = MAP_COLS - 2; col >= MAP_COLS - 5; col--) {
        for (let row = MAP_ROWS - 1; row >= 2; row--) {
            if (isSolid(col, row) && !isSolid(col, row - 1) && !isSolid(col, row - 2)) {
                GameState.level.exit.x = col * TILE_SIZE;
                GameState.level.exit.y = (row - 2) * TILE_SIZE;
                GameState.level.exit.width = 32;
                GameState.level.exit.height = 64;
                return;
            }
        }
    }
    // Fallback: rightmost standing position
    const positions = findStandingPositions();
    if (positions.length > 0) {
        const pos = positions[positions.length - 1];
        GameState.level.exit.x = pos.col * TILE_SIZE;
        GameState.level.exit.y = (pos.row - 1) * TILE_SIZE;
        GameState.level.exit.width = 32;
        GameState.level.exit.height = 64;
    }
}

/** Check if zombie overlaps the exit zone */
function checkExitZone(state) {
    return aabbOverlap(state.zombie, state.level.exit);
}

/** Render the exit zone as a gold rectangle with pulsing border */
function renderExitZone() {
    const exit = GameState.level.exit;
    // Filled gold rectangle
    ctx.fillStyle = 'rgba(255, 215, 0, 0.3)';
    ctx.fillRect(exit.x, exit.y, exit.width, exit.height);

    // Pulsing border
    const pulse = 0.5 + 0.5 * Math.sin(Date.now() / 300);
    ctx.strokeStyle = `rgba(255, 215, 0, ${0.5 + pulse * 0.5})`;
    ctx.lineWidth = 2 + pulse;
    ctx.strokeRect(exit.x, exit.y, exit.width, exit.height);

    // "EXIT" label
    ctx.fillStyle = '#ffd700';
    ctx.font = 'bold 11px Consolas, monospace';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText('EXIT', exit.x + exit.width / 2, exit.y + exit.height / 2);
}

// ============================================================
// SANITY TIER HELPERS
// Tier boundaries from paper prototype: Lucid >= 7, Slipping
// 4-6.99, Feral 0.01-3.99, Gone = 0. These thresholds match
// the validated MC simulation parameters.
// ============================================================

function getSanityTier(s) {
    if (s <= 0) return 'Gone';
    if (s < 4) return 'Feral';
    if (s < 7) return 'Slipping';
    return 'Lucid';
}

function getTierColor(tier) {
    switch (tier) {
        case 'Lucid':    return '#53d769'; // green
        case 'Slipping': return '#ffcc00'; // yellow
        case 'Feral':    return '#ff6b35'; // orange
        case 'Gone':     return '#ff3333'; // red
    }
}

function getMaxSpeed() {
    const t = getSanityT();
    return BASE_MAX_SPEED * (1 + t * (FERAL_SPEED_MULT - 1));
}

function getAcceleration() {
    const t = getSanityT();
    let accel = BASE_ACCELERATION * (1 + t * (FERAL_ACCEL_MULT - 1));

    // Reduce acceleration while airborne (air control)
    if (!zombie.grounded) {
        accel *= getAirControl();
    }
    return accel;
}

// Sanity sliding scales share a common interpolation factor:
// t = 0 at sanity 12 (Lucid), t = 1 at sanity 0 (Gone).
function getSanityT() {
    return Math.max(0, Math.min(1, (12 - sanity) / 12));
}

// Deceleration weakens as sanity drops — the zombie can't stop
// its own momentum. Creates the "committed to a direction" feel
// at low sanity (Swink: simulation weight).
function getDeceleration() {
    const t = getSanityT();
    return BASE_DECELERATION * (1 + t * (FERAL_DECEL_MULT - 1));
}

// Jump strengthens as sanity drops — the feral zombie is more
// explosive. Smooth scale, not stepped by tier.
function getJumpVelocity() {
    const t = getSanityT();
    return JUMP_VELOCITY * (1 + t * (FERAL_JUMP_MULT - 1));
}

function getAirControl() {
    const t = getSanityT();
    return BASE_AIR_CONTROL * (1 + t * (FERAL_AIR_CONTROL_MULT - 1));
}

// Gravity increases as sanity drops — tighter jump arcs at low
// sanity so Feral feels punchy, not floaty (playtest finding).
function getGravity() {
    const t = getSanityT();
    return GRAVITY * (1 + t * (FERAL_GRAVITY_MULT - 1));
}

// Drift impulse: t² curve — gentle at high sanity, devastating at low.
// At sanity 12: 0. At sanity 7: ~87. At sanity 3: ~281. At sanity 0: 500.
function getDriftImpulse() {
    const t = getSanityT();
    return DRIFT_BASE_IMPULSE * Math.pow(t, DRIFT_IMPULSE_EXPONENT);
}

// Drift interval: linear from MAX_INTERVAL at sanity 12 to MIN at sanity 0.
function getDriftInterval() {
    const t = getSanityT();
    return DRIFT_MAX_INTERVAL - (DRIFT_MAX_INTERVAL - DRIFT_MIN_INTERVAL) * t;
}

// Input delay: 0 above onset threshold, scales to FERAL_INPUT_DELAY at sanity 0.
function getInputDelay() {
    const t = getSanityT();
    if (t <= INPUT_DELAY_ONSET_T) return 0;
    return FERAL_INPUT_DELAY * (t - INPUT_DELAY_ONSET_T) / (1 - INPUT_DELAY_ONSET_T);
}

// ============================================================
// INPUT HANDLING
// Tracks key state for movement and jump. Supports both WASD
// and arrow keys. Jump uses both space and W/Up for convenience.
// Architecture note: we track jumpPressed (edge) separately
// from jumpHeld (level) because variable jump height needs to
// know when the key is released, while jump buffering needs to
// know when it was first pressed.
// ============================================================

const keysDown = new Set();

window.addEventListener('keydown', (e) => {
    if (['ArrowLeft', 'ArrowRight', 'ArrowUp', 'ArrowDown',
         'a', 'd', 'w', 's', ' ', 'r', 'R'].includes(e.key)) {
        e.preventDefault();
    }
    if (!keysDown.has(e.key)) {
        keysDown.add(e.key);
        // Edge-triggered jump detection
        if (e.key === ' ' || e.key === 'w' || e.key === 'W' || e.key === 'ArrowUp') {
            input.jumpPressed = true;
        }
    }
});

window.addEventListener('keyup', (e) => {
    keysDown.delete(e.key);
});

// Prevent stuck keys when window loses focus
window.addEventListener('blur', () => {
    keysDown.clear();
});

function processInput() {
    input.left = keysDown.has('ArrowLeft') || keysDown.has('a') || keysDown.has('A');
    input.right = keysDown.has('ArrowRight') || keysDown.has('d') || keysDown.has('D');
    input.jumpHeld = keysDown.has(' ') || keysDown.has('w') || keysDown.has('W') || keysDown.has('ArrowUp');
    // jumpPressed is consumed after use — set in keydown handler, cleared in updateJump
}

// ============================================================
// PHYSICS UPDATE
// Core movement loop. Frame-rate independent via dt. The update
// order matters: gravity -> input accel -> friction -> clamp ->
// position -> collision -> jump timers. This order prevents
// a frame of clipping after position update by resolving
// collisions before the next render.
// ============================================================

function updatePhysics(dt) {
    const tier = getSanityTier(sanity);

    // --- Gone state: no movement (phase machine handles game over) ---
    if (GameState.phase !== 'PLAYING') {
        zombie.vx = 0;
        zombie.vy = 0;
        return;
    }

    // --- Gravity ---
    zombie.vy += getGravity() * dt;

    // --- Horizontal input ---
    // Input delay: when reversing direction at low sanity, block input
    // briefly. Starts at sanity 6 (INPUT_DELAY_ONSET_T = 0.5), scales
    // smoothly to full at sanity 0. Makes momentum feel more committal
    // as the zombie loses its mind (Swink: simulation weight).
    let effectiveLeft = input.left;
    let effectiveRight = input.right;

    if (drift.inputDelayTimer > 0) {
        drift.inputDelayTimer -= dt;
        if (drift.inputDelayDirection === -1) effectiveLeft = false;
        if (drift.inputDelayDirection === 1) effectiveRight = false;
    }

    // Check for direction reversal to trigger input delay (smooth onset)
    const currentDelay = getInputDelay();
    if (currentDelay > 0) {
        if (effectiveLeft && zombie.vx > 50) {
            drift.inputDelayTimer = currentDelay;
            drift.inputDelayDirection = -1;
            effectiveLeft = false;
        } else if (effectiveRight && zombie.vx < -50) {
            drift.inputDelayTimer = currentDelay;
            drift.inputDelayDirection = 1;
            effectiveRight = false;
        }
    }

    // --- Detect high-speed direction reversal for juice ---
    // Capture vx sign BEFORE acceleration so we can detect when
    // input reverses the zombie's direction this frame.
    const prevVxSign = Math.sign(zombie.vx);
    const prevVxAbs = Math.abs(zombie.vx);

    const accel = getAcceleration();
    if (effectiveLeft)  zombie.vx -= accel * dt;
    if (effectiveRight) zombie.vx += accel * dt;

    // --- Friction (deceleration when no horizontal input) ---
    if (!effectiveLeft && !effectiveRight) {
        const friction = getDeceleration() * dt;
        if (zombie.vx > 0)      zombie.vx = Math.max(0, zombie.vx - friction);
        else if (zombie.vx < 0) zombie.vx = Math.min(0, zombie.vx + friction);
    }

    // --- Clamp to max speed ---
    const maxSpeed = getMaxSpeed();
    zombie.vx = Math.max(-maxSpeed, Math.min(maxSpeed, zombie.vx));

    // --- Update position and resolve collisions per-axis ---
    // Moving and resolving one axis at a time prevents the bug where
    // pressing into a wall causes the zombie's x to overlap the wall
    // column, and the ceiling check sees the wall tile and kills the
    // jump. By resolving X first, the zombie's horizontal position is
    // corrected before any vertical checks run.
    zombie.x += zombie.vx * dt;
    clampWorldBoundsX();
    resolveHorizontal();

    // Save vy before vertical collision for landing intensity scaling
    zombie.lastVy = zombie.vy;

    zombie.y += zombie.vy * dt;
    clampWorldBoundsY();
    resolveVertical();

    // World bottom acts as ground — resolveVertical can't detect the
    // boundary as a solid tile, so re-check after it runs
    if (!zombie.grounded && zombie.y + zombie.height >= MAP_ROWS * TILE_SIZE) {
        zombie.grounded = true;
    }

    // --- Reversal juice trigger ---
    // Fire when the zombie was moving fast in one direction and
    // acceleration reversed the sign this frame.
    const newVxSign = Math.sign(zombie.vx);
    if (prevVxSign !== 0 && newVxSign !== 0 && prevVxSign !== newVxSign
        && prevVxAbs > REVERSAL_MIN_SPEED) {
        zombie.scaleX = REVERSAL_SQUASH_X;
        if (zombie.grounded) {
            emitDust(zombie.x + zombie.width / 2, zombie.y + zombie.height,
                2, -prevVxSign * 40, 30);
        }
    }

    // --- Jump timers ---
    updateJumpTimers(dt);

    // --- Jump execution ---
    updateJump();
}

// ============================================================
// COLLISION DETECTION
// Simple AABB vs tile grid. Each axis is moved and resolved
// independently in updatePhysics: X first, then Y. This
// prevents the "wall eats jump" bug where unresolved horizontal
// overlap causes the ceiling check to see wall tiles.
//
// Ground detection uses zombie.y + zombie.height (feet pixel)
// instead of zombie.y + zombie.height - 1 (last body pixel).
// This fixes a flickering grounded state when the zombie is
// exactly 1.5 tiles tall and perfectly placed on a tile
// boundary — the last body pixel falls in the row above ground.
// ============================================================

function isSolid(col, row) {
    if (col < 0 || col >= MAP_COLS || row < 0 || row >= MAP_ROWS) return false;
    return tileMap[row][col];
}

function clampWorldBoundsX() {
    if (zombie.x < 0) {
        zombie.x = 0;
        zombie.vx = Math.max(0, zombie.vx);
    }
    if (zombie.x + zombie.width > MAP_COLS * TILE_SIZE) {
        zombie.x = MAP_COLS * TILE_SIZE - zombie.width;
        zombie.vx = Math.min(0, zombie.vx);
    }
}

function clampWorldBoundsY() {
    if (zombie.y < 0) {
        zombie.y = 0;
        zombie.vy = Math.max(0, zombie.vy);
    }
    if (zombie.y + zombie.height > MAP_ROWS * TILE_SIZE) {
        zombie.y = MAP_ROWS * TILE_SIZE - zombie.height;
        zombie.vy = 0;
        zombie.grounded = true;
    }
}

function resolveVertical() {
    const left = Math.floor(zombie.x / TILE_SIZE);
    const right = Math.floor((zombie.x + zombie.width - 1) / TILE_SIZE);

    zombie.grounded = false;

    if (zombie.vy >= 0) {
        // Falling or stationary — sense ground at feet.
        // Using zombie.y + zombie.height (not -1) so that when the
        // zombie is exactly on a tile boundary, we detect the tile
        // below its feet rather than the empty row its bottom pixel
        // occupies. This eliminates grounded flicker for non-tile-
        // aligned heights (e.g. 48px = 1.5 tiles).
        const feetRow = Math.floor((zombie.y + zombie.height) / TILE_SIZE);
        for (let col = left; col <= right; col++) {
            if (isSolid(col, feetRow)) {
                zombie.y = feetRow * TILE_SIZE - zombie.height;
                zombie.vy = 0;
                zombie.grounded = true;
                break;
            }
        }
    }

    if (zombie.vy < 0) {
        // Rising — check above
        const topRow = Math.floor(zombie.y / TILE_SIZE);
        for (let col = left; col <= right; col++) {
            if (isSolid(col, topRow)) {
                zombie.y = (topRow + 1) * TILE_SIZE;
                zombie.vy = 0;
                break;
            }
        }
    }
}

function resolveHorizontal() {
    const top = Math.floor(zombie.y / TILE_SIZE);
    const bottom = Math.floor((zombie.y + zombie.height - 1) / TILE_SIZE);

    if (zombie.vx > 0) {
        const rightCol = Math.floor((zombie.x + zombie.width - 1) / TILE_SIZE);
        for (let row = top; row <= bottom; row++) {
            if (isSolid(rightCol, row)) {
                zombie.x = rightCol * TILE_SIZE - zombie.width;
                zombie.vx = 0;
                break;
            }
        }
    }

    if (zombie.vx < 0) {
        const leftCol = Math.floor(zombie.x / TILE_SIZE);
        for (let row = top; row <= bottom; row++) {
            if (isSolid(leftCol, row)) {
                zombie.x = (leftCol + 1) * TILE_SIZE;
                zombie.vx = 0;
                break;
            }
        }
    }
}

// ============================================================
// JUMP SYSTEM
// Implements coyote time, jump buffering, and variable jump
// height. These three features are essential for responsive
// platformer feel (per Swink's input responsiveness model).
//
// Coyote time: after walking off a ledge, the player has a
//   brief window to still jump. Prevents "I was on the edge!"
// Jump buffer: pressing jump slightly before landing queues
//   the jump to fire on landing. Prevents "I pressed jump!"
// Variable height: releasing jump early cuts upward velocity,
//   giving short hops vs full jumps from one button.
// ============================================================

function updateJumpTimers(dt) {
    // --- Landing detection (before wasGrounded is overwritten) ---
    // Check grounded transition: was airborne last frame, grounded now.
    // This is the landing frame — trigger stretch, dust, and shake.
    if (zombie.grounded && !zombie.wasGrounded) {
        const landVy = Math.abs(zombie.lastVy);

        // Stretch on landing — intensity scales with fall speed
        const stretchY = 1.0 + Math.min(LAND_STRETCH_MAX_Y, landVy / LAND_VY_SCALE);
        const squashX = 1.0 - Math.min(LAND_SQUASH_MAX_X, landVy / (LAND_VY_SCALE * 1.5));
        zombie.scaleX = squashX;
        zombie.scaleY = stretchY;

        // Landing dust — more particles for harder landings
        const dustCount = Math.min(6, 2 + Math.floor(landVy / 400));
        emitDust(zombie.x + zombie.width / 2, zombie.y + zombie.height,
            dustCount, 0, 50 + landVy * 0.05);

        // Screen shake on heavy landings
        if (landVy > LANDING_SHAKE_MIN_VY) {
            const shakeIntensity = Math.min(LANDING_SHAKE_INTENSITY, landVy / 300);
            triggerShake(shakeIntensity, 0.08);
        }
    }

    zombie.wasGrounded = zombie.grounded;

    if (zombie.grounded) {
        zombie.coyoteTimer = 0;
    } else {
        zombie.coyoteTimer += dt;
    }

    if (input.jumpPressed) {
        zombie.jumpBufferTimer = JUMP_BUFFER_TIME;
        input.jumpPressed = false;
    } else {
        zombie.jumpBufferTimer = Math.max(0, zombie.jumpBufferTimer - dt);
    }
}

function updateJump() {
    const canJump = zombie.grounded || zombie.coyoteTimer < COYOTE_TIME;
    const wantsJump = zombie.jumpBufferTimer > 0;

    if (canJump && wantsJump) {
        zombie.vy = getJumpVelocity();
        zombie.grounded = false;
        zombie.coyoteTimer = COYOTE_TIME; // exhaust coyote time to prevent double jump
        zombie.jumpBufferTimer = 0;
        zombie.jumpCut = false; // reset cut flag for new jump

        // Jump launch squash — compress vertically, stretch horizontally.
        // Must happen on the SAME FRAME as the jump for responsiveness
        // (Swink: input → feedback latency must be zero).
        zombie.scaleX = JUMP_SQUASH_X;
        zombie.scaleY = JUMP_SQUASH_Y;

        // Dust burst at feet
        emitDust(zombie.x + zombie.width / 2, zombie.y + zombie.height,
            4, 0, 40);
    }

    // Variable jump height: releasing jump early cuts upward velocity (once)
    if (!input.jumpHeld && zombie.vy < 0 && !zombie.jumpCut) {
        zombie.vy *= 0.5;
        zombie.jumpCut = true;
    }
}

// ============================================================
// INPUT DRIFT (SMOOTH SYSTEM)
// Random horizontal impulses simulate the zombie's body fighting
// the player's intentions. This is the Thrill of Danger mechanic
// (Garneau/Heeter). Drift impulse and interval interpolate
// smoothly via getSanityT() — no tier boundaries, no cliffs.
//
// Impulse uses a t² curve: gentle at high sanity (barely
// perceptible nudges), devastating at low sanity (1+ tile shoves).
//
// Drift applies as a position nudge + velocity residue instead
// of pure velocity impulse. This makes BOTH directions visible:
// same-direction drift causes overshoot (pushed past your target),
// reverse drift causes undershoot. The speed clamp no longer eats
// same-direction drift (balance report finding: old system made
// 50% of drift events invisible).
//
// Airborne multiplier makes drift scariest mid-jump. Visual flash
// + directional shake + vignette scale with impulse strength.
// ============================================================

function updateDrift(dt) {
    // Tick down drift flash regardless of sanity
    if (drift.flashTimer > 0) drift.flashTimer -= dt;

    // Drift impulse from smooth curve (t² — gentle start, sharp end)
    const baseImpulse = getDriftImpulse();

    // Below threshold, drift is imperceptible — skip entirely
    if (baseImpulse < 5) {
        drift.timer = 0;
        return;
    }

    drift.timer += dt;

    if (drift.timer >= drift.nextInterval) {
        drift.timer = 0;

        let impulse = baseImpulse;

        // Airborne amplification — drift is scariest mid-jump
        if (!zombie.grounded) {
            impulse *= DRIFT_AIRBORNE_MULT;
        }

        // Random next interval (±30% around the smooth average)
        const avgInterval = getDriftInterval();
        drift.nextInterval = avgInterval * (0.7 + Math.random() * 0.6);
        drift.nextInterval = Math.max(DRIFT_MIN_INTERVAL, drift.nextInterval);

        // Apply drift: position nudge + velocity residue
        const direction = Math.random() < 0.5 ? -1 : 1;

        // Position nudge — instant displacement that bypasses speed clamp.
        // Both directions create observable movement: forward = overshoot,
        // backward = undershoot. Swept collision prevents tunneling through
        // tiles on large nudges (up to 100px at max airborne drift).
        const startX = zombie.x;
        zombie.x += direction * impulse * DRIFT_NUDGE_SCALE;
        clampWorldBoundsX();

        // Swept collision: check every column between old and new position
        // so the zombie can't teleport through solid tiles
        const cTop = Math.floor(zombie.y / TILE_SIZE);
        const cBot = Math.floor((zombie.y + zombie.height - 1) / TILE_SIZE);
        if (direction > 0) {
            const origCol = Math.floor((startX + zombie.width - 1) / TILE_SIZE);
            const newCol = Math.floor((zombie.x + zombie.width - 1) / TILE_SIZE);
            for (let c = origCol + 1; c <= newCol; c++) {
                let hit = false;
                for (let row = cTop; row <= cBot; row++) {
                    if (isSolid(c, row)) {
                        zombie.x = c * TILE_SIZE - zombie.width;
                        hit = true;
                        break;
                    }
                }
                if (hit) break;
            }
        } else {
            const origCol = Math.floor(startX / TILE_SIZE);
            const newCol = Math.floor(zombie.x / TILE_SIZE);
            for (let c = origCol - 1; c >= newCol; c--) {
                let hit = false;
                for (let row = cTop; row <= cBot; row++) {
                    if (isSolid(c, row)) {
                        zombie.x = (c + 1) * TILE_SIZE;
                        hit = true;
                        break;
                    }
                }
                if (hit) break;
            }
        }

        // Y resolution after X nudge — prevents falling off platform
        // edges when drift pushes zombie horizontally off ground
        resolveVertical();

        // Velocity residue — small momentum change for physical feel.
        // Gets corrected by acceleration/friction over the next few frames.
        zombie.vx += direction * impulse * DRIFT_VELOCITY_RESIDUE;

        // Visual feedback — all scale with impulse strength
        drift.flashTimer = 0.15;
        drift.flashDirection = direction;
        drift.lastImpulse = impulse;

        // Directional screen shake scales with impulse
        const shakeIntensity = Math.min(4, impulse / 100);
        if (shakeIntensity > 0.5) {
            triggerShake(shakeIntensity, 0.08, direction);
        }
    }
}

// ============================================================
// JUICE SYSTEMS
// Squash/stretch, particles, screen shake, and vignette. These
// close Swink's simulation → feedback loop. Without them, the
// movement system is mechanically correct but feels "dead."
//
// Architecture note: these are intentionally simple. A particle
// is 9 floats. Screen shake is a decaying offset. Squash/stretch
// is a lerp toward 1.0. No abstractions beyond what's needed —
// this is a toy, not an engine (Nystrom: YAGNI).
// ============================================================

/** Emit dust particles at a position. spreadX biases horizontal scatter. */
function emitDust(x, y, count, biasX, spread) {
    for (let i = 0; i < count; i++) {
        particles.push({
            x: x + (Math.random() - 0.5) * 10,
            y: y - 2,
            vx: biasX + (Math.random() - 0.5) * spread * 2,
            vy: -(20 + Math.random() * 40),
            life: 0.2 + Math.random() * 0.15,
            maxLife: 0.35,
            size: 3 + Math.random() * 3,
            color: '#999',
        });
    }
}

/** Trigger screen shake with intensity (pixels) and duration (seconds).
 *  Optional dirX biases shake toward a direction (-1 left, 1 right, 0 neutral). */
function triggerShake(intensity, duration, dirX) {
    // Use the stronger shake if multiple fire in the same window
    // (stacking with dampening, per Vlambeer's guidelines).
    // Directional bias follows the winning intensity.
    if (intensity > camera.shakeIntensity) {
        camera.shakeIntensity = intensity;
        camera.shakeBiasX = dirX || 0;
    }
    camera.shakeDuration = Math.max(camera.shakeDuration, duration);
    camera.shakeTimer = 0;
}

/** Update all juice systems each frame. */
function updateJuice(dt) {
    // --- Squash/stretch lerp toward 1.0 ---
    // Exponential approach: fast snap-back that settles smoothly.
    const lerpSpeed = SCALE_LERP_RATE * dt;
    zombie.scaleX += (1.0 - zombie.scaleX) * Math.min(1, lerpSpeed);
    zombie.scaleY += (1.0 - zombie.scaleY) * Math.min(1, lerpSpeed);

    // Clamp near 1.0 to avoid perpetual micro-oscillation
    if (Math.abs(zombie.scaleX - 1.0) < 0.005) zombie.scaleX = 1.0;
    if (Math.abs(zombie.scaleY - 1.0) < 0.005) zombie.scaleY = 1.0;

    // --- Particles ---
    for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        p.x += p.vx * dt;
        p.y += p.vy * dt;
        p.vy += PARTICLE_GRAVITY * dt;
        p.life -= dt;
        if (p.life <= 0) {
            particles.splice(i, 1);
        }
    }

    // --- Screen shake decay ---
    if (camera.shakeDuration > 0) {
        camera.shakeTimer += dt;
        if (camera.shakeTimer >= camera.shakeDuration) {
            camera.shakeDuration = 0;
            camera.shakeTimer = 0;
            camera.shakeIntensity = 0;
            camera.shakeBiasX = 0;
            camera.shakeX = 0;
            camera.shakeY = 0;
        } else {
            // Exponential decay: starts strong, fades out
            const progress = camera.shakeTimer / camera.shakeDuration;
            const decayedIntensity = camera.shakeIntensity * (1 - progress);
            // Random component + directional bias. Bias adds a constant
            // pull toward the drift direction so the world "lurches."
            camera.shakeX = (Math.random() - 0.5) * 2 * decayedIntensity
                + camera.shakeBiasX * decayedIntensity;
            camera.shakeY = (Math.random() - 0.5) * 2 * decayedIntensity;
        }
    }
}

/** Draw all active particles. Called during render. */
function renderParticles() {
    for (const p of particles) {
        const alpha = Math.max(0, p.life / p.maxLife);
        ctx.globalAlpha = alpha * 0.7;
        ctx.fillStyle = p.color;
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.size * alpha, 0, Math.PI * 2);
        ctx.fill();
    }
    ctx.globalAlpha = 1.0;
}

/** Draw speed lines behind the zombie when moving fast.
 *  Lines trail opposite to movement direction. Count and opacity
 *  ramp up as speed approaches max. Shimmer per frame via random
 *  y-offsets communicates sustained velocity (Celeste-style). */
function renderSpeedLines() {
    const speed = Math.abs(zombie.vx);
    const maxSpeed = getMaxSpeed();
    const threshold = maxSpeed * SPEED_LINE_THRESHOLD;
    if (speed < threshold || threshold >= maxSpeed) return;

    // 0→1 ramp from threshold to max speed
    const intensity = Math.min(1, (speed - threshold) / (maxSpeed - threshold));
    const tier = getSanityTier(sanity);
    const color = getTierColor(tier);
    const dir = zombie.vx > 0 ? -1 : 1; // trail opposite to movement
    const startX = dir > 0 ? zombie.x + zombie.width : zombie.x;
    const lineCount = intensity > 0.5 ? 2 : 1;

    ctx.strokeStyle = color;
    ctx.lineWidth = 1;

    for (let i = 0; i < lineCount; i++) {
        const yOffset = (i === 0 ? -1 : 1) * (5 + Math.random() * 10);
        const lineY = zombie.y + zombie.height / 2 + yOffset;
        const lineLen = 15 + Math.random() * 15;

        ctx.globalAlpha = SPEED_LINE_OPACITY * intensity * (0.6 + Math.random() * 0.4);
        ctx.beginPath();
        ctx.moveTo(startX, lineY);
        ctx.lineTo(startX + dir * lineLen, lineY);
        ctx.stroke();
    }
    ctx.globalAlpha = 1.0;
}

/** Draw sanity vignette overlay. Intensity scales with getSanityT(). */
function renderVignette() {
    const t = getSanityT();
    if (t < 0.05) return; // no vignette at high sanity

    const w = canvas.width;
    const h = canvas.height;
    const cx = w / 2;
    const cy = h / 2;
    const radius = Math.max(w, h) * 0.7;

    // Radial gradient: transparent center, tier-colored edges
    const tier = getSanityTier(sanity);
    const color = getTierColor(tier);

    const gradient = ctx.createRadialGradient(cx, cy, radius * 0.3, cx, cy, radius);
    gradient.addColorStop(0, 'rgba(0, 0, 0, 0)');
    gradient.addColorStop(1, color);

    ctx.globalAlpha = t * VIGNETTE_MAX_OPACITY;
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, w, h);
    ctx.globalAlpha = 1.0;
}

/** Draw a one-sided vignette flash when drift fires.
 *  Flashes on the side the drift pushed TOWARD so the player
 *  can feel the direction of the interference. Screen-space.
 *  Opacity scales with impulse strength — invisible at high sanity,
 *  dramatic at low sanity. */
function renderDriftVignette() {
    if (drift.flashTimer <= 0 || drift.flashDirection === 0) return;
    if (drift.lastImpulse < 50) return; // too weak for vignette

    const w = canvas.width;
    const h = canvas.height;
    const dir = drift.flashDirection;

    // Opacity scales with impulse strength and flash timer
    const impulseAlpha = Math.min(1, drift.lastImpulse / 300);
    const alpha = (drift.flashTimer / 0.15) * 0.2 * impulseAlpha;

    // Linear gradient from drift-direction edge toward center
    const tier = getSanityTier(sanity);
    const gradient = ctx.createLinearGradient(
        dir > 0 ? w : 0, 0,
        w * 0.5, 0
    );
    gradient.addColorStop(0, getTierColor(tier));
    gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');

    ctx.globalAlpha = alpha;
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, w, h);
    ctx.globalAlpha = 1.0;
}

// ============================================================
// RENDERING
// Canvas-based rendering. Tiles are drawn as colored rectangles,
// the zombie as a green rectangle with "Z" label. Colors shift
// by sanity tier to give visual feedback on current state.
// Architecture note: we clear and redraw every frame rather
// than using dirty rectangles because at 40x15 tiles the fill
// cost is negligible and it avoids artifact bugs.
// ============================================================

const canvas = document.getElementById('game-canvas');
const ctx = canvas.getContext('2d');

// Scale canvas to map size
resizeCanvas();

function render() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // --- Apply screen shake offset ---
    // All rendering is offset by the shake. Save/restore ensures
    // UI elements (drawn outside render()) are not affected.
    ctx.save();
    ctx.translate(camera.shakeX, camera.shakeY);

    // --- Draw tiles ---
    for (let row = 0; row < MAP_ROWS; row++) {
        for (let col = 0; col < MAP_COLS; col++) {
            if (tileMap[row][col]) {
                ctx.fillStyle = '#3a506b';
                ctx.fillRect(col * TILE_SIZE, row * TILE_SIZE, TILE_SIZE, TILE_SIZE);
                // Subtle border for tile edges
                ctx.strokeStyle = '#2c3e50';
                ctx.lineWidth = 1;
                ctx.strokeRect(col * TILE_SIZE, row * TILE_SIZE, TILE_SIZE, TILE_SIZE);
            }
        }
    }

    // --- Draw exit zone (behind entities) ---
    renderExitZone();

    // --- Draw particles (behind zombie) ---
    renderParticles();

    // --- Speed lines (behind zombie, only at high speed) ---
    renderSpeedLines();

    // --- Draw civilians (behind zombie in z-order) ---
    renderCivilians(GameState);

    // --- Draw guards (behind zombie in z-order) ---
    renderGuards(GameState);

    // --- Draw zombie with squash/stretch ---
    const tier = getSanityTier(sanity);
    let zombieColor = getTierColor(tier);

    // Drift flash: brief white flash when drift impulse fires.
    // Visual feedback so the player knows "that was drift, not me"
    // (Swink: closing the input -> simulation -> feedback loop).
    if (drift.flashTimer > 0) {
        const flashIntensity = drift.flashTimer / 0.15; // 1.0 -> 0.0
        // Blend toward white based on flash intensity
        zombieColor = `rgba(255, 255, 255, ${0.3 + 0.7 * flashIntensity})`;
    }

    // --- Feral input delay: "body resists" visual ---
    // Jitter ±1px and darken 20% so the 30ms delay reads as a
    // game mechanic ("zombie fought me") not input lag.
    let jitterX = 0, jitterY = 0;
    const resisting = drift.inputDelayTimer > 0;
    if (resisting) {
        jitterX = (Math.random() - 0.5) * 2;
        jitterY = (Math.random() - 0.5) * 2;
    }

    // Squash/stretch rendering: scale around the zombie's bottom-center
    // so the feet stay planted on the ground. Without this anchor,
    // squash on landing would push the zombie into the floor.
    const zCenterX = zombie.x + zombie.width / 2;
    const zBottomY = zombie.y + zombie.height;

    ctx.save();
    ctx.translate(zCenterX, zBottomY);
    ctx.scale(zombie.scaleX, zombie.scaleY);
    ctx.translate(-zCenterX, -zBottomY);

    // Apply jitter inside squash/stretch transform
    if (jitterX !== 0 || jitterY !== 0) {
        ctx.translate(jitterX, jitterY);
    }

    // Iframe flash: alternate alpha every 0.1s during invincibility
    if (zombie.invincibleTimer > 0) {
        const flashCycle = Math.floor(zombie.invincibleTimer / 0.1);
        ctx.globalAlpha = flashCycle % 2 === 0 ? 1.0 : 0.3;
    }

    ctx.fillStyle = zombieColor;
    ctx.fillRect(zombie.x, zombie.y, zombie.width, zombie.height);

    // Darken overlay when body is resisting direction change
    if (resisting) {
        ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
        ctx.fillRect(zombie.x, zombie.y, zombie.width, zombie.height);
    }

    // Draw the tier color as an outline during flash so the zombie
    // doesn't become invisible — the flash overlays, not replaces
    if (drift.flashTimer > 0) {
        ctx.strokeStyle = getTierColor(tier);
        ctx.lineWidth = 2;
        ctx.strokeRect(zombie.x, zombie.y, zombie.width, zombie.height);
    }

    // "Z" label
    ctx.fillStyle = '#000';
    ctx.font = 'bold 18px Consolas, monospace';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText('Z', zombie.x + zombie.width / 2, zombie.y + zombie.height / 2);

    // Restore alpha after iframe flash
    ctx.globalAlpha = 1.0;

    ctx.restore(); // end squash/stretch transform

    // --- Draw direction indicator (small arrow showing velocity) ---
    if (Math.abs(zombie.vx) > 10) {
        const arrowX = zombie.vx > 0
            ? zombie.x + zombie.width + 4
            : zombie.x - 8;
        const arrowDir = zombie.vx > 0 ? '>' : '<';
        ctx.fillStyle = zombieColor;
        ctx.font = '12px Consolas, monospace';
        ctx.textAlign = 'center';
        ctx.fillText(arrowDir, arrowX, zombie.y + zombie.height / 2);
    }

    ctx.restore(); // end screen shake transform

    // --- Sanity vignette (drawn over everything, screen-space) ---
    // Drawn AFTER restoring shake transform so the vignette stays
    // fixed on screen — the world shakes, the vignette doesn't.
    renderVignette();

    // --- Feral drift directional vignette (screen-space) ---
    // Brief flash on the side the drift pushed toward.
    renderDriftVignette();

    // --- Player-facing HUD (screen-space, drawn last) ---
    renderHUD();
}

/** Draw player-facing HUD: sanity bar + HP hearts */
function renderHUD() {
    const barX = 16, barY = 20;
    const barW = 160, barH = 12;

    // --- Sanity label ---
    ctx.font = '10px Consolas, monospace';
    ctx.textAlign = 'left';
    ctx.textBaseline = 'bottom';
    ctx.fillStyle = '#fff';
    ctx.fillText('SANITY', barX, barY - 2);

    // --- Sanity bar background ---
    ctx.fillStyle = '#333';
    ctx.fillRect(barX, barY, barW, barH);
    ctx.strokeStyle = '#555';
    ctx.lineWidth = 1;
    ctx.strokeRect(barX, barY, barW, barH);

    // --- Sanity bar fill ---
    const tier = getSanityTier(sanity);
    const fillW = Math.max(0, (sanity / 12) * barW);
    if (fillW > 0) {
        switch (tier) {
            case 'Lucid':    ctx.fillStyle = '#4a4'; break;
            case 'Slipping': ctx.fillStyle = '#da4'; break;
            case 'Feral':    ctx.fillStyle = '#d44'; break;
            default:         ctx.fillStyle = '#d44'; break;
        }
        ctx.fillRect(barX + 1, barY + 1, fillW - 2, barH - 2);
    }

    // --- HP hearts ---
    const heartY = barY + barH + 6;
    const heartSize = 10;
    const heartGap = 3;
    for (let i = 0; i < zombie.maxHP; i++) {
        const hx = barX + i * (heartSize + heartGap);
        if (i < zombie.hp) {
            ctx.fillStyle = '#e33';
        } else {
            ctx.fillStyle = '#555';
        }
        // Simple diamond shape
        ctx.beginPath();
        ctx.moveTo(hx + heartSize / 2, heartY);
        ctx.lineTo(hx + heartSize, heartY + heartSize / 2);
        ctx.lineTo(hx + heartSize / 2, heartY + heartSize);
        ctx.lineTo(hx, heartY + heartSize / 2);
        ctx.closePath();
        ctx.fill();
    }
}

// ============================================================
// UI — DEBUG PANEL
// Real-time movement diagnostics. Updates every frame. This is
// the designer's primary tool for understanding why movement
// feels wrong (Koster: making the system's patterns visible).
// ============================================================

const debugPanel = document.getElementById('debug-panel');

function updateDebugPanel() {
    const tier = getSanityTier(sanity);
    const aliveCivs = GameState.entities.civilians.filter(c => c.alive).length;
    const aliveGuards = GameState.entities.guards.filter(t => t.alive).length;
    const lines = [
        `Phase: ${GameState.phase}`,
        `Sanity: ${sanity.toFixed(1)} (${tier})${GameState.sanity.drainEnabled ? ' [DRAIN]' : ''}`,
        `HP: ${zombie.hp} / ${zombie.maxHP}${zombie.invincibleTimer > 0 ? ' [IFRAME]' : ''}`,
        `Civilians: ${aliveCivs} alive, ${GameState.stats.civiliansEaten} eaten`,
        `Guards: ${aliveGuards} alive, ${GameState.stats.guardsPounced} pounced`,
        `Velocity: (${zombie.vx.toFixed(0)}, ${zombie.vy.toFixed(0)})`,
        `Speed: ${Math.abs(zombie.vx).toFixed(0)} / ${getMaxSpeed().toFixed(0)}`,
        `Grounded: ${zombie.grounded}`,
        `Coyote: ${zombie.coyoteTimer.toFixed(2)}`,
        `Jump Buffer: ${zombie.jumpBufferTimer.toFixed(2)}`,
        `Air Control: ${getAirControl().toFixed(2)}`,
        `Drift Impulse: ${getDriftImpulse().toFixed(0)}`,
        `Drift Interval: ${getDriftInterval().toFixed(1)}s`,
        `Drift Timer: ${drift.timer.toFixed(2)}`,
        `Input Delay Max: ${(getInputDelay() * 1000).toFixed(0)}ms`,
        `Jump Vel: ${getJumpVelocity().toFixed(0)}`,
        `Decel: ${getDeceleration().toFixed(0)}`,
    ];

    if (drift.inputDelayTimer > 0) {
        lines.push(`Input Delay: ${drift.inputDelayTimer.toFixed(3)}`);
    }

    debugPanel.textContent = lines.join('\n');
}

// ============================================================
// UI — SANITY SLIDER
// The star of the UI — lets the designer instantly feel the
// difference between tiers without code changes. Must be
// responsive and real-time (Schell Lens #18: Flow — UI must
// not interrupt the testing flow).
// ============================================================

const sanitySlider = document.getElementById('sanity-slider');
const sanityLabel = document.getElementById('sanity-label');
const drainCheckbox = document.getElementById('drain-checkbox');

sanitySlider.addEventListener('input', () => {
    sanity = parseFloat(sanitySlider.value);
    GameState.sanity.value = sanity;
    updateSanityUI();
});

drainCheckbox.addEventListener('change', () => {
    GameState.sanity.drainEnabled = drainCheckbox.checked;
});

function updateSanityUI() {
    const tier = getSanityTier(sanity);
    const color = getTierColor(tier);
    sanityLabel.textContent = `Sanity: ${sanity.toFixed(1)} (${tier})`;
    sanityLabel.style.color = color;

    // Gone overlay controlled by GameState.phase, not tier
    // (phase machine handles showing/hiding overlays)
}

// ============================================================
// UI — TUNING PANEL
// Collapsible panel with sliders for all movement constants.
// Changes apply instantly — rapid iteration without editing
// code. Each slider writes directly to the corresponding let
// variable in the constants section.
// ============================================================

const tuningToggle = document.getElementById('tuning-toggle');
const tuningPanel = document.getElementById('tuning-panel');

tuningToggle.addEventListener('click', () => {
    tuningPanel.classList.toggle('open');
    tuningToggle.textContent = tuningPanel.classList.contains('open') ? 'Tuning ▼' : 'Tuning';
});

// Tuning parameter definitions: [label, variableName, min, max, step]
const tuningParams = [
    { section: 'Base Movement' },
    { label: 'Max Speed', key: 'BASE_MAX_SPEED', min: 100, max: 600, step: 10 },
    { label: 'Acceleration', key: 'BASE_ACCELERATION', min: 500, max: 3000, step: 50 },
    { label: 'Deceleration', key: 'BASE_DECELERATION', min: 500, max: 3000, step: 50 },
    { label: 'Air Control', key: 'BASE_AIR_CONTROL', min: 0, max: 1, step: 0.05 },

    { section: 'Jump' },
    { label: 'Jump Velocity', key: 'JUMP_VELOCITY', min: -800, max: -300, step: 10 },
    { label: 'Gravity', key: 'GRAVITY', min: 800, max: 2000, step: 50 },
    { label: 'Coyote Time', key: 'COYOTE_TIME', min: 0, max: 0.3, step: 0.01 },
    { label: 'Jump Buffer', key: 'JUMP_BUFFER_TIME', min: 0, max: 0.3, step: 0.01 },

    { section: 'Sanity Sliding Scales' },
    { label: 'Speed ×', key: 'FERAL_SPEED_MULT', min: 1.0, max: 3.0, step: 0.1 },
    { label: 'Accel ×', key: 'FERAL_ACCEL_MULT', min: 1.0, max: 3.0, step: 0.1 },
    { label: 'Air Ctrl ×', key: 'FERAL_AIR_CONTROL_MULT', min: 0.1, max: 1.0, step: 0.05 },
    { label: 'Jump ×', key: 'FERAL_JUMP_MULT', min: 1.0, max: 2.0, step: 0.05 },
    { label: 'Decel ×', key: 'FERAL_DECEL_MULT', min: 0.1, max: 1.0, step: 0.05 },
    { label: 'Gravity ×', key: 'FERAL_GRAVITY_MULT', min: 1.0, max: 2.0, step: 0.05 },

    { section: 'Drift (Smooth)' },
    { label: 'Base Impulse', key: 'DRIFT_BASE_IMPULSE', min: 100, max: 800, step: 25 },
    { label: 'Impulse Exp', key: 'DRIFT_IMPULSE_EXPONENT', min: 1.0, max: 3.0, step: 0.25 },
    { label: 'Min Interval', key: 'DRIFT_MIN_INTERVAL', min: 0.3, max: 2.0, step: 0.1 },
    { label: 'Max Interval', key: 'DRIFT_MAX_INTERVAL', min: 2.0, max: 10.0, step: 0.5 },
    { label: 'Airborne ×', key: 'DRIFT_AIRBORNE_MULT', min: 1.0, max: 4.0, step: 0.25 },
    { label: 'Nudge Scale', key: 'DRIFT_NUDGE_SCALE', min: 0.02, max: 0.2, step: 0.01 },
    { label: 'Vel Residue', key: 'DRIFT_VELOCITY_RESIDUE', min: 0.0, max: 0.6, step: 0.05 },
    { label: 'Max Delay', key: 'FERAL_INPUT_DELAY', min: 0, max: 0.1, step: 0.005 },
    { label: 'Delay Onset', key: 'INPUT_DELAY_ONSET_T', min: 0.2, max: 0.8, step: 0.05 },

    { section: 'Juice' },
    { label: 'Scale Lerp', key: 'SCALE_LERP_RATE', min: 4, max: 25, step: 1 },
    { label: 'Jump Sqsh X', key: 'JUMP_SQUASH_X', min: 1.0, max: 1.4, step: 0.05 },
    { label: 'Jump Sqsh Y', key: 'JUMP_SQUASH_Y', min: 0.6, max: 1.0, step: 0.05 },
    { label: 'Land Str Y', key: 'LAND_STRETCH_MAX_Y', min: 0.05, max: 0.4, step: 0.05 },
    { label: 'Land Shake', key: 'LANDING_SHAKE_INTENSITY', min: 1, max: 8, step: 1 },
    { label: 'Vignette', key: 'VIGNETTE_MAX_OPACITY', min: 0, max: 0.5, step: 0.05 },
    { label: 'Spd Thresh', key: 'SPEED_LINE_THRESHOLD', min: 0.5, max: 1.0, step: 0.05 },
    { label: 'Spd Opacity', key: 'SPEED_LINE_OPACITY', min: 0, max: 0.6, step: 0.05 },

    { section: 'Sanity System' },
    { label: 'Drain Rate', key: 'SANITY_DRAIN_RATE', min: 0.05, max: 0.5, step: 0.01 },
    { label: 'Per Eat', key: 'SANITY_PER_EAT', min: 1, max: 8, step: 1 },
    { label: 'Scream Range', key: 'SCREAM_ALERT_RANGE', min: 32, max: 256, step: 16 },
    { label: 'Scream Dur', key: 'SCREAM_ALERT_DURATION', min: 1.0, max: 6.0, step: 0.5 },

    { section: 'Health' },
    { label: 'Max HP', key: 'ZOMBIE_MAX_HP', min: 1, max: 10, step: 1 },
    { label: 'Iframe Dur', key: 'INVINCIBILITY_DURATION', min: 0.25, max: 2.0, step: 0.05 },

    { section: 'Civilian AI' },
    { label: 'Flee Speed', key: 'CIVILIAN_FLEE_SPEED', min: 20, max: 150, step: 5 },
    { label: 'Flee Range', key: 'CIVILIAN_FLEE_RANGE', min: 32, max: 192, step: 8 },
    { label: 'Wander Spd', key: 'CIVILIAN_WANDER_SPEED', min: 10, max: 80, step: 5 },

    { section: 'Guard AI' },
    { label: 'Patrol Spd', key: 'GUARD_SPEED', min: 40, max: 240, step: 10 },
    { label: 'Chase Spd', key: 'GUARD_CHASE_SPEED', min: 80, max: 400, step: 10 },
    { label: 'Damage', key: 'GUARD_DAMAGE', min: 1, max: 5, step: 1 },
    { label: 'Detect Rng', key: 'GUARD_DETECTION_RANGE', min: 64, max: 320, step: 16 },
    { label: 'Watch Rng', key: 'GUARD_WATCH_RANGE', min: 16, max: 192, step: 8 },
    { label: 'Patrol Rng', key: 'GUARD_PATROL_RANGE', min: 32, max: 256, step: 16 },
    { label: 'Leash Dist', key: 'GUARD_LEASH_DISTANCE', min: 64, max: 320, step: 16 },
    { label: 'Pounce San', key: 'POUNCE_SANITY_THRESHOLD', min: 1, max: 8, step: 1 },
];

// We store references to the global variables via eval for live read/write.
// Architecture note: using eval here is acceptable because the keys are
// hardcoded string literals defined above — no user input reaches eval.
function buildTuningPanel() {
    let html = '';

    for (const param of tuningParams) {
        if (param.section) {
            html += `<div class="section-label">${param.section}</div>`;
            continue;
        }

        const currentVal = eval(param.key);
        const id = `tune-${param.key}`;
        html += `
            <label>
                <span>${param.label}</span>
                <input type="range" id="${id}" min="${param.min}" max="${param.max}"
                       step="${param.step}" value="${currentVal}"
                       data-key="${param.key}">
                <span id="${id}-val" style="min-width:45px;text-align:right">${currentVal}</span>
            </label>
        `;
    }

    // Level Generator section (Room Grid)
    html += `<div class="section-label">Level Generator</div>`;
    html += `
        <label><span>Grid</span>
            <span style="min-width:90px;text-align:right;font-size:10px">${GRID_COLS}x${GRID_ROWS} rooms (${GRID_COLS * ROOM_W}x${GRID_ROWS * ROOM_H} tiles)</span>
        </label>
        <label><span>Density</span>
            <input type="range" id="gen-density" min="10" max="90" step="5" value="50">
            <span id="gen-density-val" style="min-width:45px;text-align:right">0.5</span>
        </label>
        <label><span>Min Sanity</span>
            <input type="range" id="gen-sanity" min="1" max="12" step="1" value="12">
            <span id="gen-sanity-val" style="min-width:45px;text-align:right">12</span>
        </label>
        <label><span>Seed</span>
            <input type="number" id="gen-seed" value="42" class="gen-seed-input">
        </label>
        <div class="gen-button-row">
            <button onclick="doGenerate()">Room Grid</button>
            <button onclick="doRandomGenerate()">Random</button>
        </div>
        <div class="gen-button-row">
            <button onclick="loadLevel1()">Level 1</button>
            <button onclick="loadPresetGauntlet()">Gauntlet</button>
        </div>
    `;

    tuningPanel.innerHTML = html;

    // Attach listeners for tuning sliders
    for (const param of tuningParams) {
        if (param.section) continue;
        const id = `tune-${param.key}`;
        const slider = document.getElementById(id);
        const valSpan = document.getElementById(`${id}-val`);

        slider.addEventListener('input', () => {
            const val = parseFloat(slider.value);
            // Write to the global variable
            eval(`${param.key} = ${val}`);
            valSpan.textContent = param.step < 1 ? val.toFixed(2) : val;
        });
    }

    // Attach listeners for generator sliders
    document.getElementById('gen-density').addEventListener('input', function() {
        document.getElementById('gen-density-val').textContent = (this.value / 100).toFixed(1);
    });
    document.getElementById('gen-sanity').addEventListener('input', function() {
        document.getElementById('gen-sanity-val').textContent = this.value;
    });
}

// ============================================================
// GAME LOOP
// Fixed-timestep-ish loop using requestAnimationFrame. We cap
// dt to 0.05s (20fps minimum) to prevent the "spiral of death"
// where large dt causes physics to explode, which causes even
// larger dt next frame.
// ============================================================

let lastTime = 0;

function gameLoop(currentTime) {
    const deltaTime = (currentTime - lastTime) / 1000;
    lastTime = currentTime;

    // Cap dt to prevent physics explosion on tab-switch or lag spike
    const dt = Math.min(deltaTime, 0.05);

    // Skip the first frame (deltaTime would be huge)
    if (deltaTime > 0 && deltaTime < 1) {
        if (GameState.phase === 'PLAYING') {
            processInput();
            updateSanityDrain(GameState, dt);
            updateHealth(GameState, dt);
            GameState.stats.timeElapsed += dt;
            updatePhysics(dt);
            updateCivilians(GameState, dt);
            updateGuards(GameState, dt);
            checkEatCollision(GameState);
            checkGuardCollision(GameState);
            updateDrift(dt);
            updateJuice(dt);
        }
        updateGamePhase(GameState);
        render();
        updateDebugPanel();
        updateSanityUI();
    }

    requestAnimationFrame(gameLoop);
}

// ============================================================
// INITIALIZATION
// Set up everything and start the loop. Canvas is already sized
// in the rendering section. Tuning panel is built dynamically.
// ============================================================

function init() {
    buildTuningPanel();
    updateSanityUI();
    loadLevel1();
    requestAnimationFrame(gameLoop);
}

init();
</script>
</body>
</html>
